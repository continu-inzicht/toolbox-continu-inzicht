---
title: "Overstromingsrisico scenarios"
---

Scenarios worden gebruikt om de mogelijke gevolgen van overstromingen in kaart te brengen. <br>
Hiermee kan de kans uit een fragilitycruve gecombineerd worden met de gevolgen die bepaald zijn bij een scenario om zo een beter inzicht te krijgen in het totale risico. <br>
Dit kan helpen om prioriteiten te stellen op basis van een totaal beeld en niet alleen op basis van kans of gevolg afzonderlijk. <br>
Om de scenarios te kunnen combineren moeten er een aantal stappen worden doorlopen:
- Omrekenen van dijkvakkansen naar trajectdeelkansen ([CalculateFloodScenarioProbability](#sec-CalculateFloodScenarioProbability))
- Belasting per deeltraject bepalen ([LoadFromFloodScenarioProbabilit](#sec-LoadFromFloodScenarioProbabilit))
- Met de belasting een bijpassende overstromingscenario selecteren ([SelectFloodScenarioFromLoad ](#sec-SelectFloodScenarioFromLoad))
- Van het scenario en de curve een geagregeerd risico bepalen ([CalculateFloodRisk](#sec-CalculateFloodRisk))

```mermaid
graph TD
    A[CalculateFloodScenarioProbability] --> B[LoadFromFloodScenarioProbabilit]
    B --> C[SelectFloodScenarioFromLoad]
    C --> D[CalculateFloodRisk]
```

## CalculateFloodScenarioProbability{sec-CalculateFloodScenarioProbability}

Voor het berekenen van overstromingsrisico scenarios moeten de faalkansen van vakken gecobineerd worden tot faalkansen die vergeleken kunnen worden met de kansen van overstromingsscenario's. Hierbij wordt gebruik gemaakt van de gecombineerde kans van het vak en deze worden gecombineerd naar traject delen.

```mermaid
graph TD
    A1[Dijkvak/section] --> D[Dijktraject deel/segment]
    B1[Dijkvak/section] --> D
    B2[Dijkvak/section] --> D
    C1[Dijkvak/section] --> E[Dijktraject deel/segment]
    C2[Dijkvak/section] --> E
    E --> F
    D --> F[Overstromingskans gebied/Dikesystem]
```

Dit voorbeeld laat zien hoe dit gedaan kan worden met behulp van de `CalculateFloodScenarioProbability` stap in de TBCI toolbox.
Hiervoor is de gecombineerde faalkans per dijkvak nodig en een mapping van dijkvakken naar dijktraject delen van daar naar de overstromingsscenario gebieden.

::: {.panel-tabset}
## Configuratie
```yaml
GlobalVariables:
    rootdir: "data_sets"
    moments: [-24,0,24,48]

DataAdapter:
    default_options:
        csv:
            sep: ","
    combined_failure_probability_data:
        type: csv
        file: "combined_failure_probability_data.csv"
    section_id_to_segment_id:
        type: csv
        file: "section_id_to_segment_id.csv"
    segment_failure_probability:
        type: csv
        file: "segment_failure_probability.csv"
```
## Code
```python
from toolbox_continu_inzicht import Config, DataAdapter
from toolbox_continu_inzicht.flood_scenarios import CalculateFloodScenarioProbability

config = Config(config_path="config.yaml")
config.lees_config()
data_adapter = DataAdapter(config=config)
calculate_flood_scenario_probability = CalculateFloodScenarioProbability(
    data_adapter=data_adapter
)
calculate_flood_scenario_probability.run(
    input=["combined_failure_probability_data", "section_id_to_segment_id"],
    output="segment_failure_probability",
)
```
:::


## LoadFromFloodScenarioProbability{sec-LoadFromFloodScenarioProbability}

Met de faalkansen per trajectdeel kunnen met de `LoadFromFloodScenarioProbability` de belastingen per trajectdeel worden bepaald.
Hiermee kan een bijpassend overstromingsscenario worden geselecteerd.
Met de input van de vorige stap `segment_failure_probability`, kan een koppeling worden gemaakt naar de bijbehorende bres en fragilitycurve die representatief is voor een deeltraject met de tabel `breach_id_to_segment_id`.
Zolang de koppeling van deze id's overeenkomt, is deze door de gebruiker te configureren. De bestaande vak-indelingen kunnen worden gebruikt, maar er kunnen ook andere curves worden gebruikt.
Deze `representative_section_id_fragilitycurve` kan vervolgens uit de data van de curves in `section_failure_probability_data` worden gehaald.
Met de fragilitycurve worden de hydraulische belastingen bepaald voor de deeltrajecten.

::: {.panel-tabset}
## Configuratie
```yaml
GlobalVariables:
    rootdir: "data_sets"
    moments: [-24,0,24,48]

DataAdapter:
    default_options:
        csv:
            sep: ","
    segment_failure_probability:
        type: csv
        file: "segment_failure_probability.csv"
    breach_id_to_segment_id:
        type: csv
        file: "breach_id_to_segment_id.csv"
    section_failure_probability_data:
        type: csv
        file: "fragility_curve_multi_section.csv"
    flood_scenario_load_resultaten:
        type: csv
        path: "flood_scenario_load_resultaten.csv"
```
## Code
```python
from toolbox_continu_inzicht import Config, DataAdapter
from toolbox_continu_inzicht.flood_scenarios import LoadFromFloodScenarioProbability

config = Config(config_path="config.yaml")
config.lees_config()
data_adapter = DataAdapter(config=config)
load_from_flood_scenario_probability = LoadFromFloodScenarioProbability(
    data_adapter=data_adapter
)
load_from_flood_scenario_probability.run(
    input=[
        "segment_failure_probability",
        "breach_id_to_segment_id",
        "section_failure_probability_data",
    ],
    output="flood_scenario_load_resultaten",
)
```
:::

## SelectFloodScenarioFromLoad{sec-SelectFloodScenarioFromLoad}

Met de maatgevende belastingen per trajectdeel (resultaat van [LoadFromFloodScenarioProbability](#sec-LoadFromFloodScenarioProbability)), kan een bijbehorend scenario worden geselecteerd.
Hiervoor is metadata per bres nodig. Hierbij wordt voor de volgende functie alvast de koppeling gemaakt met de bijbehorende grids. Deze grids per scenario worden in [CalculateFloodRisk](#sec-CalculateFloodRisk) gebruikt om het overstromingsrisico te bepalen gegeven de huidige belasting.

De eerste data adapter is de output van `LoadFromFloodScenarioProbability` met daarin per dijktraject id (`segment_id`) de bijbehorende belasting en bres id (`hydraulicload`,`breach_id`).

De tweede data adapter bevat per bres id (`breach_id`) een bijbehorende maximale belasting waarvoor een scenario geldig is (`hydraulicload_upperboundary`).
Op basis van deze belasting wordt een koppeling gemaakt van de huidige belasting naar een scenario.
Hierbij is de standaardoptie om maar één resultaat per dijktraject terug te geven.
Hierbij moet de waterstand overschreden zijn waarbij het scenario hoort.
Om het mogelijk te maken voor de gebruiker om te kiezen tussen twee scenario's kan de optie `return_two_scenarios` op `True` worden gezet.
In dit geval worden de onder- en bovengrens teruggegeven.
Hiermee is het ook mogelijk om tussen de twee scenario's te kiezen.

De data adapter moet minimaal 1 kolom met een grid naam bevatten die eindigt op `_grid`.

Standaard worden 4 namen gebruikt:

- slachtoffers (`casualties_grid`)
- schade (`damage_grid`)
- plaatgebonden overstromingskans (`flooding_grid`)
- getroffenen (`affected_people_grid`)

Deze worden meegenomen naar het output bestand, wat gebruikt wordt in de input van de functie `CalculateFloodRisk`.

::: {.panel-tabset}
## Configuratie
```yaml
GlobalVariables:
    rootdir: "data_sets"
    moments: [ -24, 0, 24, 48 ]
    SelectFloodScenarioFromLoad:
        return_two_scenarios: False # Default


DataAdapter:
    default_options:
        csv:
            sep: ","
    flood_scenario_loads:
        type: csv
        path: "flood_scenario_load_resultaten.csv"
    breach_location_metadata:
        type: csv
        path: "breach_location_metadata.csv"
    flood_scenario_grids:
        type: csv
        path: "flood_scenario_grids.csv"
```
## Code
```python
from toolbox_continu_inzicht import Config, DataAdapter
from toolbox_continu_inzicht.flood_scenarios import SelectFloodScenarioFromLoad
config = Config(config_path="config.yaml")
config.lees_config()
data_adapter = DataAdapter(config=config)
select_flood_scenario_from_load = SelectFloodScenarioFromLoad(
    data_adapter=data_adapter
)
select_flood_scenario_from_load.run(
    input=[
        "flood_scenario_loads",
        "breach_location_metadata",
    ],
    output="flood_scenario_load_resultaten",
)
```
:::


## CalculateFloodRisk{sec-CalculateFloodRisk}

CalculateFloodRisk brengt alle functies tot nu toe samen om het actuele overstromingsrisco in kaart te brengen voor een gegeven gebied.

De eerste data adapter is de output van `SelectFloodScenarioFromLoad` met daarin per dijktraject id (`segment_id`) de bijbehorende faalkans.

De tweede data adapter bevat per dijktraject id (`segment_id`) de bijbehorende grids. Ook hier mogen de namen alles zijn wat eindigt op `_grid`.

Deze naamgeving wordt hergebruikt in de output. De standaardinstellingen voor het middelen zijn:

|Kolomnaam|Variable|Type middeling|
|--|--|--|
|casualties_grid|casualties|sum|
|damage_grid|damage|sum|
|flooding_grid|flooding|median|
|affected_people_grid|affectedpeople|sum|

Mocht de gebruiker een andere kolom naam willen, dan kan deze in de globalvariable worden opgegeven zoals hieronder in het configuratie voorbeeld wordt getoond.

Als derde adapter moet een shapefile worden opgegeven waarover wordt gemiddeld. Hier is de kolom `area_id` verplicht, met een uniek id naast de `geometry` kolom.

Ook moet een pad worden opgegeven waar de scenario's staan.

Hier zijn 4 opties:
 - een absoluut pad
 - relatief pad ten opzichte van de `rootdir`
 - relatief pad ten opzichte van de `current work directory` waaruit het script wordt gedraaid
 - los in de data dir zelf

De output van de functie kan ook aangepast worden om het resultaat per hectaren terug te geven. In dat geval moet `per_hectare` op `true` worden gezet en moet `columns_per_hectare` worden gevuld met een lijst van de kolom namen die per hectaren worden berekend. In de output wordt `_per_ha` toegevoegd om verwarring te voorkomen.
```yaml
per_hectare: False
columns_per_hectare:
  - casualties
  - damage
  - affected_people
  - flooding
```

::: {.panel-tabset}
## Configuratie
```yaml
GlobalVariables:
    rootdir: "data_sets"
    moments: [ -24, 0, 24, 48 ]
    CalculateFloodRisk:
        scenario_path: 'flood_scenarios'
        averaging_methods: # default waardes
            casualties: sum
            damage: sum
            flooding: median
            affectedpeople: sum
        per_hectare: False

DataAdapter:
    default_options:
        csv:
            sep: ","
    segment_failure_probability:
        type: csv
        path: "segment_failure_probability.csv"
    flood_scenario_grids:
        type: csv
        path: "flood_scenario_grids.csv"
    areas_to_average:
        type: shape
        path: "areas_to_average.geojson"
    flood_risk_results:
        type: csv
        path: "flood_risk_results.csv"
```
## Code
```python
from toolbox_continu_inzicht import Config, DataAdapter
from toolbox_continu_inzicht.flood_scenarios import CalculateFloodRisk
config = Config(config_path="config.yaml")
config.lees_config()
data_adapter = DataAdapter(config=config)
calculate_flood_risk = CalculateFloodRisk(data_adapter=data_adapter)
calculate_flood_risk.run(
    input=[
        "segment_failure_probability",
        "flood_scenario_grids",
        "areas_to_average",
    ],
    output="flood_risk_results",
)
```
:::
