[
  {
    "objectID": "tests.html",
    "href": "tests.html",
    "title": "Testprotocol",
    "section": "",
    "text": "Elk ontwikkeld script wordt getest. Dit testprotocol bestaat uit unittesten en integratietesten. Met unittesten testen we of de individuele componenten van de broncode goed werken (bijv. als de gebruiker foutieve data opgeeft). Bij het maken van unittesten is het doel om een totale dekking van 80% te halen over de gehele code, dit kan gecontroleerd worden met pytest -cov. Bij sommige modules is dit het makkelijk om alle code te vatten in een test, in die gevallen is dit dan ook de bedoeling om dit te doen. Doordat de interactie met een postgresql database of FEWS REST-API niet makkelijk te verwerken is in een automatische test, is er per functie geen strikte eis. Om toch de interactie met componenten die beveiligd zijn en om de samenwerking tussen de verschillende scripts te controleren, worden integratietesten uitgevoerd. In de ontwikkelfase vinden deze integratietesten plaats aan het einde van de sprints door een deel van de project groep die niet de code actief heeft ontwikkeld. In de beheerfase zal het team dat de code blijft beheren deze integratie testen blijven uitvoeren.",
    "crumbs": [
      "Overig",
      "Testprotocol"
    ]
  },
  {
    "objectID": "reference/SectionsTechnicalFailureprobability.html",
    "href": "reference/SectionsTechnicalFailureprobability.html",
    "title": "SectionsTechnicalFailureprobability",
    "section": "",
    "text": "sections.SectionsTechnicalFailureprobability()\nBepaal de technische faalkans van een dijkvak\n\n\n**input_schema_fragility_curves (DataFrame): schema voor fragility curves voor de dijkvak\n\nsection_id: int64 : id van het dijkvak\nfailuremechanism: str : code van het faalmechanisme\nhydraulicload: float64 : belasting\nfailureprobability: float64 : faalkans\n\n**df_in_section_loads (DataFrame): schema voor tijdreeks met belasting op de dijkvak\n\nsection_id: int64 : id van het dijkvak\nparameter_id: int64 : id van de belastingparameter (1,2,3,4)\nunit: str : eenheid van de belastingparameter\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : belasting van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\n\n\n\n\n**df_out (DataFrame): uitvoer\n\nsection_id: int64 : id van het dijkvak\nparameter_id: int64 : id van de faalkans parameter (5,100,101,102)\nunit: str : eenheid van de belastingparameter\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : belasting van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\nfailureprobability float64 : faalkans bepaald voor de tijdreeksitem\nfailuremechanism: str : code van het faalmechanisme\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in_fragility_curves\nDataFrame: fragility curves voor de dijkvak.\n\n\ndf_in_section_loads\nDataFrame: tijdreeks met belasting op de dijkvak.\n\n\ndf_out\nDataFrame: uitvoer.\n\n\ninput_schema_fragility_curves\ndict() -&gt; new empty dictionary\n\n\ninput_schema_loads\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun\nUitvoeren van het bepalen van de faalkans van een dijkvak.\n\n\n\n\n\nsections.SectionsTechnicalFailureprobability.run(input, output)\nUitvoeren van het bepalen van de faalkans van een dijkvak.\nArgs:\ninput (list[str]): Lijst met namen van configuratie:\n    [0] tijdreeks met belasting op de dijkvak\n    [1] fragility curves voor de dijkvak\noutput (str): uitvoer sectie van het yaml-bestand."
  },
  {
    "objectID": "reference/SectionsTechnicalFailureprobability.html#input-schemas",
    "href": "reference/SectionsTechnicalFailureprobability.html#input-schemas",
    "title": "SectionsTechnicalFailureprobability",
    "section": "",
    "text": "**input_schema_fragility_curves (DataFrame): schema voor fragility curves voor de dijkvak\n\nsection_id: int64 : id van het dijkvak\nfailuremechanism: str : code van het faalmechanisme\nhydraulicload: float64 : belasting\nfailureprobability: float64 : faalkans\n\n**df_in_section_loads (DataFrame): schema voor tijdreeks met belasting op de dijkvak\n\nsection_id: int64 : id van het dijkvak\nparameter_id: int64 : id van de belastingparameter (1,2,3,4)\nunit: str : eenheid van de belastingparameter\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : belasting van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)"
  },
  {
    "objectID": "reference/SectionsTechnicalFailureprobability.html#output-schema",
    "href": "reference/SectionsTechnicalFailureprobability.html#output-schema",
    "title": "SectionsTechnicalFailureprobability",
    "section": "",
    "text": "**df_out (DataFrame): uitvoer\n\nsection_id: int64 : id van het dijkvak\nparameter_id: int64 : id van de faalkans parameter (5,100,101,102)\nunit: str : eenheid van de belastingparameter\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : belasting van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\nfailureprobability float64 : faalkans bepaald voor de tijdreeksitem\nfailuremechanism: str : code van het faalmechanisme"
  },
  {
    "objectID": "reference/SectionsTechnicalFailureprobability.html#attributes",
    "href": "reference/SectionsTechnicalFailureprobability.html#attributes",
    "title": "SectionsTechnicalFailureprobability",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in_fragility_curves\nDataFrame: fragility curves voor de dijkvak.\n\n\ndf_in_section_loads\nDataFrame: tijdreeks met belasting op de dijkvak.\n\n\ndf_out\nDataFrame: uitvoer.\n\n\ninput_schema_fragility_curves\ndict() -&gt; new empty dictionary\n\n\ninput_schema_loads\ndict() -&gt; new empty dictionary"
  },
  {
    "objectID": "reference/SectionsTechnicalFailureprobability.html#methods",
    "href": "reference/SectionsTechnicalFailureprobability.html#methods",
    "title": "SectionsTechnicalFailureprobability",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrun\nUitvoeren van het bepalen van de faalkans van een dijkvak.\n\n\n\n\n\nsections.SectionsTechnicalFailureprobability.run(input, output)\nUitvoeren van het bepalen van de faalkans van een dijkvak.\nArgs:\ninput (list[str]): Lijst met namen van configuratie:\n    [0] tijdreeks met belasting op de dijkvak\n    [1] fragility curves voor de dijkvak\noutput (str): uitvoer sectie van het yaml-bestand."
  },
  {
    "objectID": "reference/SectionsLoads.html",
    "href": "reference/SectionsLoads.html",
    "title": "SectionsLoads",
    "section": "",
    "text": "sections.SectionsLoads()\nBepaal de belasting op een dijkvak\n\n\n**input_schema_sections (DataFrame): schema voor de lijst met dijkvakken\n\nid: int64 : id van het dijkvak\nname: str : naam van de dijkvak\n\n**input_schema_loads (DataFrame): schema voor belasting per moment per meetlocaties\n\nmeasurement_location_id: int64 : id van het meetstation\nparameter_id: int64 : id van de belastingparameter (1,2,3,4)\nunit: str : eenheid van de belastingparameter\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : waarde van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\n\n**input_schema_section_fractions (DataFrame): schema voor koppeling van de maatgevende meetlocaties per dijkvak\n\nid: int64 : id van de dijkvak\nidup: int64 : id van bovenstrooms meetstation\niddown: int64 : id van benedenstrooms meetstation\nfractionup: float64 : fractie van bovenstrooms meetstation\nfractiondown: float64 : fractie van benedestrooms meetstation\n\n\n\n\n**df_out (DataFrame): uitvoer\n\nid: int64 : id van het dijkvak\nname; str : naam van de dijkvak\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : waarde van de tijdreeksitem\nunit: str : eenheid van de belastingparameter\nparameter_id: int64 : id van de belastingparameter (1,2,3,4)\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\nDataAdapter: De data adapter.\n\n\ndf_in_loads\nDataFrame: belasting per moment per meetlocaties.\n\n\ndf_in_section_fractions\nDataFrame: koppeling van de maatgevende meetlocaties per dijkvak .\n\n\ndf_in_sections\nDataFrame: lijst met dijkvakken.\n\n\ndf_out\nDataFrame: uitvoer.\n\n\ninput_schema_loads\ndict() -&gt; new empty dictionary\n\n\ninput_schema_section_fractions\ndict() -&gt; new empty dictionary\n\n\ninput_schema_sections\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun\nBepalen de belasting op een dijkvak.\n\n\n\n\n\nsections.SectionsLoads.run(input, output)\nBepalen de belasting op een dijkvak.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] lijst met dijkvakken [1] belasting per moment per meetlocaties [2] koppeling van de maatgevende meetlocaties per dijkvak\nrequired\n\n\noutput\nstr\nuitvoer sectie van het yaml-bestand: koppeling van de maatgevende meetlocaties per dijkvak\nrequired"
  },
  {
    "objectID": "reference/SectionsLoads.html#input-schemas",
    "href": "reference/SectionsLoads.html#input-schemas",
    "title": "SectionsLoads",
    "section": "",
    "text": "**input_schema_sections (DataFrame): schema voor de lijst met dijkvakken\n\nid: int64 : id van het dijkvak\nname: str : naam van de dijkvak\n\n**input_schema_loads (DataFrame): schema voor belasting per moment per meetlocaties\n\nmeasurement_location_id: int64 : id van het meetstation\nparameter_id: int64 : id van de belastingparameter (1,2,3,4)\nunit: str : eenheid van de belastingparameter\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : waarde van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\n\n**input_schema_section_fractions (DataFrame): schema voor koppeling van de maatgevende meetlocaties per dijkvak\n\nid: int64 : id van de dijkvak\nidup: int64 : id van bovenstrooms meetstation\niddown: int64 : id van benedenstrooms meetstation\nfractionup: float64 : fractie van bovenstrooms meetstation\nfractiondown: float64 : fractie van benedestrooms meetstation"
  },
  {
    "objectID": "reference/SectionsLoads.html#output-schema",
    "href": "reference/SectionsLoads.html#output-schema",
    "title": "SectionsLoads",
    "section": "",
    "text": "**df_out (DataFrame): uitvoer\n\nid: int64 : id van het dijkvak\nname; str : naam van de dijkvak\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : waarde van de tijdreeksitem\nunit: str : eenheid van de belastingparameter\nparameter_id: int64 : id van de belastingparameter (1,2,3,4)\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)"
  },
  {
    "objectID": "reference/SectionsLoads.html#attributes",
    "href": "reference/SectionsLoads.html#attributes",
    "title": "SectionsLoads",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\nDataAdapter: De data adapter.\n\n\ndf_in_loads\nDataFrame: belasting per moment per meetlocaties.\n\n\ndf_in_section_fractions\nDataFrame: koppeling van de maatgevende meetlocaties per dijkvak .\n\n\ndf_in_sections\nDataFrame: lijst met dijkvakken.\n\n\ndf_out\nDataFrame: uitvoer.\n\n\ninput_schema_loads\ndict() -&gt; new empty dictionary\n\n\ninput_schema_section_fractions\ndict() -&gt; new empty dictionary\n\n\ninput_schema_sections\ndict() -&gt; new empty dictionary"
  },
  {
    "objectID": "reference/SectionsLoads.html#methods",
    "href": "reference/SectionsLoads.html#methods",
    "title": "SectionsLoads",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrun\nBepalen de belasting op een dijkvak.\n\n\n\n\n\nsections.SectionsLoads.run(input, output)\nBepalen de belasting op een dijkvak.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] lijst met dijkvakken [1] belasting per moment per meetlocaties [2] koppeling van de maatgevende meetlocaties per dijkvak\nrequired\n\n\noutput\nstr\nuitvoer sectie van het yaml-bestand: koppeling van de maatgevende meetlocaties per dijkvak\nrequired"
  },
  {
    "objectID": "reference/SectionsClassify.html",
    "href": "reference/SectionsClassify.html",
    "title": "SectionsClassify",
    "section": "",
    "text": "sections.SectionsClassify()\nBepaal de status van een dijkvak\n\n\n**input_schema_thresholds (DataFrame): schema voor klassegrenzen per dijkvak\n\nlower_boundary: float64 : ondergrens van de klassegrens\nupper_boundary: float64 : bovengrens van de klassegrens\nstate_id: int64 : id van de klassegrens\n\n**input_schema_failureprobability (DataFrame): schema voor faalkans per moment per dijkvak\n\nsection_id: int64 : id van het dijkvak\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : faalkans van de tijdreeksitem\n\n\n\n\n**df_out (DataFrame): uitvoer\n\nfailureprobability_id: in64 : id van de dijkvak/faalmechanisme/maatregel combinatie\nsection_id: int64 : id van het dijkvak\nvalue_parameter_id : id van de belasting parameter (1,2,3,4)\nfailuremechanism_id: int64 : id van het faalmechanisme\nfailuremechanism: str : code van het faalmechanisme\nmeasures_id: int : id van de maatregel\nmeasure str : naam van de maatregel\nparameter_id: int64 : id van de faalkans parameter (5,100,101,102)\nunit: str : eenheid van de belastingparameter\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : faalkans van de tijdreeksitem\nstate_id: int64 : id van de klassegrens\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in_failureprobability\n\n\n\ndf_in_thresholds\n\n\n\ndf_out\n\n\n\ninput_schema_failureprobability\ndict() -&gt; new empty dictionary\n\n\ninput_schema_thresholds\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun\nBepaal de status van een dijkvak\n\n\n\n\n\nsections.SectionsClassify.run(input, output)\nBepaal de status van een dijkvak\nArgs: input List(str): [0] klassegrenzen [1] faalkans per dijkvak output (str): uitvoer sectie van het yaml-bestand: koppeling van de maatgevende meetlocaties per dijkvak"
  },
  {
    "objectID": "reference/SectionsClassify.html#input-schemas",
    "href": "reference/SectionsClassify.html#input-schemas",
    "title": "SectionsClassify",
    "section": "",
    "text": "**input_schema_thresholds (DataFrame): schema voor klassegrenzen per dijkvak\n\nlower_boundary: float64 : ondergrens van de klassegrens\nupper_boundary: float64 : bovengrens van de klassegrens\nstate_id: int64 : id van de klassegrens\n\n**input_schema_failureprobability (DataFrame): schema voor faalkans per moment per dijkvak\n\nsection_id: int64 : id van het dijkvak\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : faalkans van de tijdreeksitem"
  },
  {
    "objectID": "reference/SectionsClassify.html#output-schema",
    "href": "reference/SectionsClassify.html#output-schema",
    "title": "SectionsClassify",
    "section": "",
    "text": "**df_out (DataFrame): uitvoer\n\nfailureprobability_id: in64 : id van de dijkvak/faalmechanisme/maatregel combinatie\nsection_id: int64 : id van het dijkvak\nvalue_parameter_id : id van de belasting parameter (1,2,3,4)\nfailuremechanism_id: int64 : id van het faalmechanisme\nfailuremechanism: str : code van het faalmechanisme\nmeasures_id: int : id van de maatregel\nmeasure str : naam van de maatregel\nparameter_id: int64 : id van de faalkans parameter (5,100,101,102)\nunit: str : eenheid van de belastingparameter\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : faalkans van de tijdreeksitem\nstate_id: int64 : id van de klassegrens"
  },
  {
    "objectID": "reference/SectionsClassify.html#attributes",
    "href": "reference/SectionsClassify.html#attributes",
    "title": "SectionsClassify",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in_failureprobability\n\n\n\ndf_in_thresholds\n\n\n\ndf_out\n\n\n\ninput_schema_failureprobability\ndict() -&gt; new empty dictionary\n\n\ninput_schema_thresholds\ndict() -&gt; new empty dictionary"
  },
  {
    "objectID": "reference/SectionsClassify.html#methods",
    "href": "reference/SectionsClassify.html#methods",
    "title": "SectionsClassify",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrun\nBepaal de status van een dijkvak\n\n\n\n\n\nsections.SectionsClassify.run(input, output)\nBepaal de status van een dijkvak\nArgs: input List(str): [0] klassegrenzen [1] faalkans per dijkvak output (str): uitvoer sectie van het yaml-bestand: koppeling van de maatgevende meetlocaties per dijkvak"
  },
  {
    "objectID": "reference/output_section.html",
    "href": "reference/output_section.html",
    "title": "output_section",
    "section": "",
    "text": "base.adapters.output.continu_inzicht_postgresql.output_section\nData adapters voor het schrijven naar de Continu Inzicht database\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_failuremechanisms\nOphalen lijst met faalmechanismes uit de Continu Inzicht database\n\n\nget_parameters\nOphalen lijst met parameters uit de Continu Inzicht database\n\n\noutput_ci_postgresql_section\nSchrijft secties naar de Continu Inzicht database (tabel: sections).\n\n\noutput_ci_postgresql_section_load_to_data\nSchrijft data voor dijkvakken de belasting naar Continu Inzicht database (tabel: data)\n\n\noutput_ci_postgresql_section_to_data\nSchrijft data naar Continu Inzicht database\n\n\noutput_ci_postgresql_section_to_states\nSchrijft state naar Continu Inzicht database\n\n\noutput_ci_postgresql_sectionfractions\nSchrijft (interpolatie)fracties van meetlocatie per sectie naar de Continu Inzicht database (tabel: sectionfractions).\n\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.get_failuremechanisms(\n    engine\n    schema\n)\nOphalen lijst met faalmechanismes uit de Continu Inzicht database\nFaalmechanismes: code: naam COMB: Combinatie faalmechanismen GEKB: Overloop en overslag dijken STPH: Opbarsten en piping dijken STBI: Stabiliteit binnenwaarts dijken HTKW: Overloop en overslag langsconstructies STKWl: Stabiliteit langsconstructies PKW: Piping langsconstructies\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.get_parameters(\n    engine\n    schema\n)\nOphalen lijst met parameters uit de Continu Inzicht database\nFaalmechanismes: code: naam H10: Gemeten waterstand H10V: Voorspelde waterstand H10EH: Voorspelde waterstand ensemble hoog H10EL: Voorspelde waterstand ensemble laag PF: Faalkans BO: Beheerdersoordeel MR: Maatregel RSCH: Risico verwachte schade RSL: Risico verwachte slachtoffers RGETR: Risico getroffenen RPLPF: Risico plaatsgebonden overstromingskans PFT: Faalkans technical PFM: Faalkans measure PFEJ: Faalkans expert judgement\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.output_ci_postgresql_section(\n    output_config\n    df\n)\nSchrijft secties naar de Continu Inzicht database (tabel: sections).\nYaml example:\ntype: ci_postgresql_section\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_whatif\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- id: int64                 : id van de sectie\n- segmentid: int64          : id van het segment waartoe de sectie behoort\n- name: str                 : naam van de sectie\n- geometry: geom            : geometrie (ligging) van de sectie (let op projectie altijd EPSG4326!)\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.output_ci_postgresql_section_load_to_data(\n    output_config\n    df\n)\nSchrijft data voor dijkvakken de belasting naar Continu Inzicht database (tabel: data)\nYaml example:\ntype: ci_postgresql_section_load_to_data\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nunit_conversion_factor: 0.01\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- measurement_location_id: int64\n- date_time: datetime64[ns, UTC]\n- value: float64\n- value_type: str\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.output_ci_postgresql_section_to_data(\n    output_config\n    df\n)\nSchrijft data naar Continu Inzicht database\n\n\noutput_config (dict):\n\n\n\nIn de .env environment bestand moeten de volgende parameters staan: postgresql_user (str): postgresql_password (str): postgresql_host (str): postgresql_port (str):\nIn de ‘yaml’ config moeten de volgende parameters staan: database (str): schema (str):\n\n\n\npd.Dataframe\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.output_ci_postgresql_section_to_states(\n    output_config\n    df\n)\nSchrijft state naar Continu Inzicht database\n\n\noutput_config (dict):\n\n\n\nIn de .env environment bestand moeten de volgende parameters staan: postgresql_user (str): postgresql_password (str): postgresql_host (str): postgresql_port (str):\nIn de ‘yaml’ config moeten de volgende parameters staan: database (str): schema (str):\n\n\n\npd.Dataframe\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.output_ci_postgresql_sectionfractions(\n    output_config\n    df\n)\nSchrijft (interpolatie)fracties van meetlocatie per sectie naar de Continu Inzicht database (tabel: sectionfractions).\nYaml example:\ntype: ci_postgresql_sectionfractions\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_whatif\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- sectionid: int64          : id van de sectie\n- idup: int64               : id van het meetlocatie (measuringlocation), stroomopwaarst gelegen (indien van toepassing)\n- iddown: int64             : id van het meetlocatie (measuringlocation), stroomafwaarst gelegen (indien van toepassing)\n- fractionup: float64       : fractie van de belasting gebruikt voor interpolatie belasting bij sectie stroomopwaarst gelegen (indien van toepassing)\n- fractiondown: float64     : fractie van de belasting gebruikt voor interpolatie belasting bij sectie stroomafwaarst gelegen (indien van toepassing)\n- parameters: XXXXXX          : OPTIONEEL lijst van (belasting)parameters (ROLF VRAGEN)\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht"
  },
  {
    "objectID": "reference/output_section.html#functions",
    "href": "reference/output_section.html#functions",
    "title": "output_section",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_failuremechanisms\nOphalen lijst met faalmechanismes uit de Continu Inzicht database\n\n\nget_parameters\nOphalen lijst met parameters uit de Continu Inzicht database\n\n\noutput_ci_postgresql_section\nSchrijft secties naar de Continu Inzicht database (tabel: sections).\n\n\noutput_ci_postgresql_section_load_to_data\nSchrijft data voor dijkvakken de belasting naar Continu Inzicht database (tabel: data)\n\n\noutput_ci_postgresql_section_to_data\nSchrijft data naar Continu Inzicht database\n\n\noutput_ci_postgresql_section_to_states\nSchrijft state naar Continu Inzicht database\n\n\noutput_ci_postgresql_sectionfractions\nSchrijft (interpolatie)fracties van meetlocatie per sectie naar de Continu Inzicht database (tabel: sectionfractions).\n\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.get_failuremechanisms(\n    engine\n    schema\n)\nOphalen lijst met faalmechanismes uit de Continu Inzicht database\nFaalmechanismes: code: naam COMB: Combinatie faalmechanismen GEKB: Overloop en overslag dijken STPH: Opbarsten en piping dijken STBI: Stabiliteit binnenwaarts dijken HTKW: Overloop en overslag langsconstructies STKWl: Stabiliteit langsconstructies PKW: Piping langsconstructies\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.get_parameters(\n    engine\n    schema\n)\nOphalen lijst met parameters uit de Continu Inzicht database\nFaalmechanismes: code: naam H10: Gemeten waterstand H10V: Voorspelde waterstand H10EH: Voorspelde waterstand ensemble hoog H10EL: Voorspelde waterstand ensemble laag PF: Faalkans BO: Beheerdersoordeel MR: Maatregel RSCH: Risico verwachte schade RSL: Risico verwachte slachtoffers RGETR: Risico getroffenen RPLPF: Risico plaatsgebonden overstromingskans PFT: Faalkans technical PFM: Faalkans measure PFEJ: Faalkans expert judgement\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.output_ci_postgresql_section(\n    output_config\n    df\n)\nSchrijft secties naar de Continu Inzicht database (tabel: sections).\nYaml example:\ntype: ci_postgresql_section\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_whatif\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- id: int64                 : id van de sectie\n- segmentid: int64          : id van het segment waartoe de sectie behoort\n- name: str                 : naam van de sectie\n- geometry: geom            : geometrie (ligging) van de sectie (let op projectie altijd EPSG4326!)\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.output_ci_postgresql_section_load_to_data(\n    output_config\n    df\n)\nSchrijft data voor dijkvakken de belasting naar Continu Inzicht database (tabel: data)\nYaml example:\ntype: ci_postgresql_section_load_to_data\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nunit_conversion_factor: 0.01\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- measurement_location_id: int64\n- date_time: datetime64[ns, UTC]\n- value: float64\n- value_type: str\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.output_ci_postgresql_section_to_data(\n    output_config\n    df\n)\nSchrijft data naar Continu Inzicht database\n\n\noutput_config (dict):\n\n\n\nIn de .env environment bestand moeten de volgende parameters staan: postgresql_user (str): postgresql_password (str): postgresql_host (str): postgresql_port (str):\nIn de ‘yaml’ config moeten de volgende parameters staan: database (str): schema (str):\n\n\n\npd.Dataframe\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.output_ci_postgresql_section_to_states(\n    output_config\n    df\n)\nSchrijft state naar Continu Inzicht database\n\n\noutput_config (dict):\n\n\n\nIn de .env environment bestand moeten de volgende parameters staan: postgresql_user (str): postgresql_password (str): postgresql_host (str): postgresql_port (str):\nIn de ‘yaml’ config moeten de volgende parameters staan: database (str): schema (str):\n\n\n\npd.Dataframe\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_section.output_ci_postgresql_sectionfractions(\n    output_config\n    df\n)\nSchrijft (interpolatie)fracties van meetlocatie per sectie naar de Continu Inzicht database (tabel: sectionfractions).\nYaml example:\ntype: ci_postgresql_sectionfractions\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_whatif\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- sectionid: int64          : id van de sectie\n- idup: int64               : id van het meetlocatie (measuringlocation), stroomopwaarst gelegen (indien van toepassing)\n- iddown: int64             : id van het meetlocatie (measuringlocation), stroomafwaarst gelegen (indien van toepassing)\n- fractionup: float64       : fractie van de belasting gebruikt voor interpolatie belasting bij sectie stroomopwaarst gelegen (indien van toepassing)\n- fractiondown: float64     : fractie van de belasting gebruikt voor interpolatie belasting bij sectie stroomafwaarst gelegen (indien van toepassing)\n- parameters: XXXXXX          : OPTIONEEL lijst van (belasting)parameters (ROLF VRAGEN)\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht"
  },
  {
    "objectID": "reference/output_calculation.html",
    "href": "reference/output_calculation.html",
    "title": "output_calculation",
    "section": "",
    "text": "base.adapters.output.continu_inzicht_postgresql.output_calculation\nData adapters voor het schrijven naar de Continu Inzicht database\n\n\n\n\n\nName\nDescription\n\n\n\n\noutput_ci_postgresql_to_calculation_end\n- Update de datetime in de Continu Inzicht database tabel moments\n\n\noutput_ci_postgresql_to_calculation_start\nUpdate de calculatietijd in de Continu Inzicht database tabel moments\n\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_calculation.output_ci_postgresql_to_calculation_end(\n    output_config\n    df\n)\n\nUpdate de datetime in de Continu Inzicht database tabel moments\nVerwijderd alle data waar calculating op False staat\nZet alle data waar calculating op True staat naar False\n\nYaml example:\n type: ci_postgresql_to_calculation_end\n database: \"geoserver\"\n schema: \"continuinzicht_demo_realtime\"\nArgs:\n * output_config (dict): configuratie opties\n * df (DataFrame): geen data nodig\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_calculation.output_ci_postgresql_to_calculation_start(\n    output_config\n    df\n)\nUpdate de calculatietijd in de Continu Inzicht database tabel moments\nYaml example:\ntype: ci_postgresql_to_calculation_start\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- moment_id: int64\n- calc_time: datetime64[ns, UTC]\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht"
  },
  {
    "objectID": "reference/output_calculation.html#functions",
    "href": "reference/output_calculation.html#functions",
    "title": "output_calculation",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\noutput_ci_postgresql_to_calculation_end\n- Update de datetime in de Continu Inzicht database tabel moments\n\n\noutput_ci_postgresql_to_calculation_start\nUpdate de calculatietijd in de Continu Inzicht database tabel moments\n\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_calculation.output_ci_postgresql_to_calculation_end(\n    output_config\n    df\n)\n\nUpdate de datetime in de Continu Inzicht database tabel moments\nVerwijderd alle data waar calculating op False staat\nZet alle data waar calculating op True staat naar False\n\nYaml example:\n type: ci_postgresql_to_calculation_end\n database: \"geoserver\"\n schema: \"continuinzicht_demo_realtime\"\nArgs:\n * output_config (dict): configuratie opties\n * df (DataFrame): geen data nodig\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_calculation.output_ci_postgresql_to_calculation_start(\n    output_config\n    df\n)\nUpdate de calculatietijd in de Continu Inzicht database tabel moments\nYaml example:\ntype: ci_postgresql_to_calculation_start\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- moment_id: int64\n- calc_time: datetime64[ns, UTC]\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht"
  },
  {
    "objectID": "reference/LoadsWaterinfo.html",
    "href": "reference/LoadsWaterinfo.html",
    "title": "LoadsWaterinfo",
    "section": "",
    "text": "loads.LoadsWaterinfo()\nBelastinggegevens ophalen van rijkswaterstaat Waterinfo https://waterinfo.rws.nl/#/publiek/waterhoogte\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out\n\n\n\ninput_schema\ndict() -&gt; new empty dictionary\n\n\nurl\nstr(object=’’) -&gt; str\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate_dataframe\nMaak een pandas dataframe van de opgehaalde data uit Waterinfo\n\n\nget_maptype\nbepaal welke schema gebruikt moet worden voor het ophalen van de belasting\n\n\nget_value_by_observedhours\nbepaal welke range gebruikt moet worden voor het ophalen van de belasting\n\n\nrun\nDe runner van de Belasting Waterinfo functie.\n\n\n\n\n\nloads.LoadsWaterinfo.create_dataframe(\n    options\n    maptype_schema\n    measuringstation\n    json_data\n)\nMaak een pandas dataframe van de opgehaalde data uit Waterinfo\nArgs: options (dict): options opgegeven in de yaml maptype_schema (dict): gegevens van de maptype measuringstation (dict): gegevens van het meetstation json_data (str): JSON data met opgehaalde belasting data\nReturns: Dataframe: Pandas dataframe geschikt voor uitvoer: definition: - Meetlocatie id (measurement_location_id) - Meetlocatie code (measurement_location_code) - Meetlocatie omschrijving/naam (measurement_location_description) - Parameter id overeenkomstig Aquo-standaard: �4724� (parameter_id) - Parameter code overeenkomstig Aquo-standaard: �WATHTE� (parameter_code) - Parameter omschrijving overeenkomstig Aquo-standaard: �Waterhoogte� (parameter_description) - Eenheid (unit) - Datum en tijd (date_time) - Waarde (value) - Type waarde: meting of verwachting (value_type)\n\n\n\nloads.LoadsWaterinfo.get_maptype(maptype)\nbepaal welke schema gebruikt moet worden voor het ophalen van de belasting\nArgs: maptype (str): maptypes: - waterhoogte, - wind, - golfhoogte, - watertemperatuur, - luchttemperatuur, - astronomische-getij, - waterafvoer, - zouten\nreturns: de query van de range als string. voorbeeld: -48,0\n\n\n\nloads.LoadsWaterinfo.get_value_by_observedhours(\n    maptype_schema\n    observedhours_moments\n)\nbepaal welke range gebruikt moet worden voor het ophalen van de belasting\nArgs: maptype_schema (dict): schema met mogelijke ranges. Voorbeeld: {“observedhours”: 48, “predictionhours”: 48, “query”: “-48,0”}, {“observedhours”: 6, “predictionhours”: 3, “query”: “-6,0”}, {“observedhours”: 216, “predictionhours”: 48, “query”: “-216,0”}, {“observedhours”: 672, “predictionhours”: 0, “query”: “-672,0”} observedhours_moments (int): het laagste moment.\nreturns: de query van de range als string. voorbeeld: -48,0\n\n\n\nloads.LoadsWaterinfo.run(input, output)\nDe runner van de Belasting Waterinfo functie.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nstr\nNaam van de dataadapter met invoergegevens.\nrequired\n\n\noutput\nstr\nNaam van de dataadapter om uitvoergegevens op te slaan.\nrequired"
  },
  {
    "objectID": "reference/LoadsWaterinfo.html#attributes",
    "href": "reference/LoadsWaterinfo.html#attributes",
    "title": "LoadsWaterinfo",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out\n\n\n\ninput_schema\ndict() -&gt; new empty dictionary\n\n\nurl\nstr(object=’’) -&gt; str"
  },
  {
    "objectID": "reference/LoadsWaterinfo.html#methods",
    "href": "reference/LoadsWaterinfo.html#methods",
    "title": "LoadsWaterinfo",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncreate_dataframe\nMaak een pandas dataframe van de opgehaalde data uit Waterinfo\n\n\nget_maptype\nbepaal welke schema gebruikt moet worden voor het ophalen van de belasting\n\n\nget_value_by_observedhours\nbepaal welke range gebruikt moet worden voor het ophalen van de belasting\n\n\nrun\nDe runner van de Belasting Waterinfo functie.\n\n\n\n\n\nloads.LoadsWaterinfo.create_dataframe(\n    options\n    maptype_schema\n    measuringstation\n    json_data\n)\nMaak een pandas dataframe van de opgehaalde data uit Waterinfo\nArgs: options (dict): options opgegeven in de yaml maptype_schema (dict): gegevens van de maptype measuringstation (dict): gegevens van het meetstation json_data (str): JSON data met opgehaalde belasting data\nReturns: Dataframe: Pandas dataframe geschikt voor uitvoer: definition: - Meetlocatie id (measurement_location_id) - Meetlocatie code (measurement_location_code) - Meetlocatie omschrijving/naam (measurement_location_description) - Parameter id overeenkomstig Aquo-standaard: �4724� (parameter_id) - Parameter code overeenkomstig Aquo-standaard: �WATHTE� (parameter_code) - Parameter omschrijving overeenkomstig Aquo-standaard: �Waterhoogte� (parameter_description) - Eenheid (unit) - Datum en tijd (date_time) - Waarde (value) - Type waarde: meting of verwachting (value_type)\n\n\n\nloads.LoadsWaterinfo.get_maptype(maptype)\nbepaal welke schema gebruikt moet worden voor het ophalen van de belasting\nArgs: maptype (str): maptypes: - waterhoogte, - wind, - golfhoogte, - watertemperatuur, - luchttemperatuur, - astronomische-getij, - waterafvoer, - zouten\nreturns: de query van de range als string. voorbeeld: -48,0\n\n\n\nloads.LoadsWaterinfo.get_value_by_observedhours(\n    maptype_schema\n    observedhours_moments\n)\nbepaal welke range gebruikt moet worden voor het ophalen van de belasting\nArgs: maptype_schema (dict): schema met mogelijke ranges. Voorbeeld: {“observedhours”: 48, “predictionhours”: 48, “query”: “-48,0”}, {“observedhours”: 6, “predictionhours”: 3, “query”: “-6,0”}, {“observedhours”: 216, “predictionhours”: 48, “query”: “-216,0”}, {“observedhours”: 672, “predictionhours”: 0, “query”: “-672,0”} observedhours_moments (int): het laagste moment.\nreturns: de query van de range als string. voorbeeld: -48,0\n\n\n\nloads.LoadsWaterinfo.run(input, output)\nDe runner van de Belasting Waterinfo functie.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nstr\nNaam van de dataadapter met invoergegevens.\nrequired\n\n\noutput\nstr\nNaam van de dataadapter om uitvoergegevens op te slaan.\nrequired"
  },
  {
    "objectID": "reference/LoadsMatroos.html",
    "href": "reference/LoadsMatroos.html",
    "title": "LoadsMatroos",
    "section": "",
    "text": "loads.LoadsMatroos()\nDe LoadsMatroos klasse haalt belastinggegevens op van de Rijkswaterstaat Waterwebservices.\nArgs: data_adapter: DataAdapter De data adapter voor het ophalen en opslaan van gegevens. df_in: Optional[pd.DataFrame] | None = None Het invoerdataframe. df_out: Optional[pd.DataFrame] | None = None Het uitvoerdataframe.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out\n\n\n\nurl_retrieve_series_matroos\nstr(object=’’) -&gt; str\n\n\nurl_retrieve_series_noos\nstr(object=’’) -&gt; str\n\n\nurl_retrieve_series_vitaal\nstr(object=’’) -&gt; str\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate_dataframe\nMaakt een dataframe met waardes van de rws water webservices\n\n\nformat_location_names\nNeemt een lijst met locatienamen en verwijdert spaties en maakt ze allemaal in kleine letters\n\n\ngenerate_url\nGeeft de benodigde URL terug om het verzoek naar de Noos-server te maken\n\n\nrun\nVoert de functie uit om gegevens op te halen en te verwerken voor de matroos-toolbox.\n\n\n\n\n\nloads.LoadsMatroos.create_dataframe(options, df_in, calc_time, json_data)\nMaakt een dataframe met waardes van de rws water webservices\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noptions\ndict\nEen dictionary met opties uit de config\nrequired\n\n\ncalc_time\ndatetime\nDe huidige tijd\nrequired\n\n\njson_data\nlist\nEen lijst met JSON data\nrequired\n\n\n\n\n\n\npd.Dataframe\n    Pandas dataframe geschikt voor uitvoer\n\n\n\n\nloads.LoadsMatroos.format_location_names(location_names)\nNeemt een lijst met locatienamen en verwijdert spaties en maakt ze allemaal in kleine letters\n\n\n\nloads.LoadsMatroos.generate_url(\n    calc_time\n    options\n    global_variables\n    parameter\n    location_names\n)\nGeeft de benodigde URL terug om het verzoek naar de Noos-server te maken\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncalc_time\n\nHuidige tijd, wordt gebruikt om de meest recente voorspelling op te halen\nrequired\n\n\noptions\n\nOpties die door de gebruiker zijn opgegeven, in dit geval is ‘source’ het belangrijkst\nrequired\n\n\nglobal_variables\n\nGlobale variabelen die nodig zijn om de URL te genereren\nrequired\n\n\nparameter\n\nEenheid van de parameter waarvoor gegevens worden opgehaald\nrequired\n\n\nlocation_names\n\nLijst van locatienamen waarvoor gegevens worden opgehaald\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nDe gegenereerde URL voor het verzoek aan de Noos-server\n\n\n\n\n\n\n\nloads.LoadsMatroos.run(input, output)\nVoert de functie uit om gegevens op te halen en te verwerken voor de matroos-toolbox.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nstr\nNaam van de dataadapter met invoergegevens.\nrequired\n\n\noutput\nstr\nNaam van de dataadapter om uitvoergegevens op te slaan.\nrequired"
  },
  {
    "objectID": "reference/LoadsMatroos.html#attributes",
    "href": "reference/LoadsMatroos.html#attributes",
    "title": "LoadsMatroos",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out\n\n\n\nurl_retrieve_series_matroos\nstr(object=’’) -&gt; str\n\n\nurl_retrieve_series_noos\nstr(object=’’) -&gt; str\n\n\nurl_retrieve_series_vitaal\nstr(object=’’) -&gt; str"
  },
  {
    "objectID": "reference/LoadsMatroos.html#methods",
    "href": "reference/LoadsMatroos.html#methods",
    "title": "LoadsMatroos",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncreate_dataframe\nMaakt een dataframe met waardes van de rws water webservices\n\n\nformat_location_names\nNeemt een lijst met locatienamen en verwijdert spaties en maakt ze allemaal in kleine letters\n\n\ngenerate_url\nGeeft de benodigde URL terug om het verzoek naar de Noos-server te maken\n\n\nrun\nVoert de functie uit om gegevens op te halen en te verwerken voor de matroos-toolbox.\n\n\n\n\n\nloads.LoadsMatroos.create_dataframe(options, df_in, calc_time, json_data)\nMaakt een dataframe met waardes van de rws water webservices\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noptions\ndict\nEen dictionary met opties uit de config\nrequired\n\n\ncalc_time\ndatetime\nDe huidige tijd\nrequired\n\n\njson_data\nlist\nEen lijst met JSON data\nrequired\n\n\n\n\n\n\npd.Dataframe\n    Pandas dataframe geschikt voor uitvoer\n\n\n\n\nloads.LoadsMatroos.format_location_names(location_names)\nNeemt een lijst met locatienamen en verwijdert spaties en maakt ze allemaal in kleine letters\n\n\n\nloads.LoadsMatroos.generate_url(\n    calc_time\n    options\n    global_variables\n    parameter\n    location_names\n)\nGeeft de benodigde URL terug om het verzoek naar de Noos-server te maken\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncalc_time\n\nHuidige tijd, wordt gebruikt om de meest recente voorspelling op te halen\nrequired\n\n\noptions\n\nOpties die door de gebruiker zijn opgegeven, in dit geval is ‘source’ het belangrijkst\nrequired\n\n\nglobal_variables\n\nGlobale variabelen die nodig zijn om de URL te genereren\nrequired\n\n\nparameter\n\nEenheid van de parameter waarvoor gegevens worden opgehaald\nrequired\n\n\nlocation_names\n\nLijst van locatienamen waarvoor gegevens worden opgehaald\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nstr\nDe gegenereerde URL voor het verzoek aan de Noos-server\n\n\n\n\n\n\n\nloads.LoadsMatroos.run(input, output)\nVoert de functie uit om gegevens op te halen en te verwerken voor de matroos-toolbox.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nstr\nNaam van de dataadapter met invoergegevens.\nrequired\n\n\noutput\nstr\nNaam van de dataadapter om uitvoergegevens op te slaan.\nrequired"
  },
  {
    "objectID": "reference/LoadsClassify.html",
    "href": "reference/LoadsClassify.html",
    "title": "LoadsClassify",
    "section": "",
    "text": "loads.LoadsClassify()\nMet deze functie worden de waterstanden met opgegeven grenzen geclassificeerd.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in_loads\n\n\n\ndf_in_thresholds\n\n\n\ndf_out\n\n\n\ninput_schema_loads\ndict() -&gt; new empty dictionary\n\n\ninput_schema_thresholds\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun\nDe runner van de Loads Classify.\n\n\n\n\n\nloads.LoadsClassify.run(input, output)\nDe runner van de Loads Classify.\nArgs: input List(str): [0] lijst met drempelwaarden per meetlocatie [1] belasting per moment per meetlocaties output (str): uitvoer sectie van het yaml-bestand: koppeling van de maatgevende meetlocaties per dijkvak\nReturns: Dataframe: Pandas dataframe met geclassificeerde waterstanden voor opgegeven momenten."
  },
  {
    "objectID": "reference/LoadsClassify.html#attributes",
    "href": "reference/LoadsClassify.html#attributes",
    "title": "LoadsClassify",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in_loads\n\n\n\ndf_in_thresholds\n\n\n\ndf_out\n\n\n\ninput_schema_loads\ndict() -&gt; new empty dictionary\n\n\ninput_schema_thresholds\ndict() -&gt; new empty dictionary"
  },
  {
    "objectID": "reference/LoadsClassify.html#methods",
    "href": "reference/LoadsClassify.html#methods",
    "title": "LoadsClassify",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrun\nDe runner van de Loads Classify.\n\n\n\n\n\nloads.LoadsClassify.run(input, output)\nDe runner van de Loads Classify.\nArgs: input List(str): [0] lijst met drempelwaarden per meetlocatie [1] belasting per moment per meetlocaties output (str): uitvoer sectie van het yaml-bestand: koppeling van de maatgevende meetlocaties per dijkvak\nReturns: Dataframe: Pandas dataframe met geclassificeerde waterstanden voor opgegeven momenten."
  },
  {
    "objectID": "reference/input_section.html",
    "href": "reference/input_section.html",
    "title": "input_section",
    "section": "",
    "text": "base.adapters.input.continu_inzicht_postgresql.input_section\nData adapters voor het lezen van data uit de Continu Inzicht database\n\n\n\n\n\nName\nDescription\n\n\n\n\ninput_ci_postgresql_from_sectionfractions\nOphalen sections fractions uit een continu database.\n\n\ninput_ci_postgresql_from_sections\nOphalen section data uit de Continu Inzicht database.\n\n\ninput_ci_postgresql_section_expert_judgement_table\nOphalen klassegrenzen (faalkans) van een dijkvak uit een continu database.\n\n\ninput_ci_postgresql_section_failure_probability_from_data_table\nOphalen faalkansen per dijkvak per moment\n\n\ninput_ci_postgresql_section_load_from_data_table\nOphalen tijdreeks van belasting per dijkvak\n\n\ninput_ci_postgresql_section_thresholds_from_conditions_table\nOphalen klassegrenzen (faalkans) van een dijkvak uit een continu database.\n\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_section.input_ci_postgresql_from_sectionfractions(\n    input_config\n)\nOphalen sections fractions uit een continu database.\nYaml example:\ntype: ci_postgresql_from_sectionfractions\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nid: int64 : id van de dijkvak\nidup: int64 : id van bovenstrooms meetstation\niddown: int64 : id van benedestrooms meetstation\nfractionup: float64 : fractie van bovenstrooms meetstation\nfractiondown: float64 : fractie van benedestrooms meetstation\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_section.input_ci_postgresql_from_sections(\n    input_config\n)\nOphalen section data uit de Continu Inzicht database.\nYaml example:\ntype: ci_postgresql_from_sections\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nid: int64 : id van de dijkvak\nname: str : naam van de dijkvak\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_section.input_ci_postgresql_section_expert_judgement_table(\n    input_config\n)\nOphalen klassegrenzen (faalkans) van een dijkvak uit een continu database.\nYaml example:\ntype: ci_postgresql_section_thresholds_from_conditions_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nstate_id: int64 : id van de klassegrens\nlower_boundary: float64 : ondergrens van de klassegrens\nupper_boundary: float64 : bovengrens van de klassegrens\ncolor: str : kleur van de klassegrens\nlabel: str : legendanaam van de klassegrens\nunit: str : unit van de klassegrens\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_section.input_ci_postgresql_section_failure_probability_from_data_table(\n    input_config\n)\nOphalen faalkansen per dijkvak per moment\nYaml example:\ntype: ci_postgresql_section_failure_probability_from_data_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nfailureprobability_id: in64 : id van de dijkvak/faalmechanisme/maatregel combinatie\nsection_id: int64 : id van de dijkvak\nvalue_parameter_id: int64 : id van de belasting parameter (1/2/3/4)\nfailuremechanism_id: int64 : id van het faalmechanisme\nfailuremechanism: str : naam van het faalmechanisme\nmeasures_id: int64 : id van de maatregel\nmeasure: str : naam van de maatregel\nparameter_id: int64 : id van de faalkans parameter (5/100/101/102)\nunit: int64 : unit van de belasting\ndate_time: datetime64 : datum/ tijd van de tijdreeksitem\nvalue: float : waarde van de tijdreeksitem\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_section.input_ci_postgresql_section_load_from_data_table(\n    input_config\n)\nOphalen tijdreeks van belasting per dijkvak\nYaml example:\ntype: ci_postgresql_section_load_from_data_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nsection_id: int64 : id van de dijkvak\nparameter_id: int64 : id van de parameter\nunit: str : unit van de parameter\ndate_time: datetime64 : datum/ tijd van de tijdreeksitem\nvalue: float64 : waarde van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_section.input_ci_postgresql_section_thresholds_from_conditions_table(\n    input_config\n)\nOphalen klassegrenzen (faalkans) van een dijkvak uit een continu database.\nYaml example:\ntype: ci_postgresql_section_thresholds_from_conditions_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nstate_id: int64 : id van de klassegrens\nlower_boundary: float64 : ondergrens van de klassegrens\nupper_boundary: float64 : bovengrens van de klassegrens\ncolor: str : kleur van de klassegrens\nlabel: str : legendanaam van de klassegrens\nunit: str : unit van de klassegrens"
  },
  {
    "objectID": "reference/input_section.html#functions",
    "href": "reference/input_section.html#functions",
    "title": "input_section",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ninput_ci_postgresql_from_sectionfractions\nOphalen sections fractions uit een continu database.\n\n\ninput_ci_postgresql_from_sections\nOphalen section data uit de Continu Inzicht database.\n\n\ninput_ci_postgresql_section_expert_judgement_table\nOphalen klassegrenzen (faalkans) van een dijkvak uit een continu database.\n\n\ninput_ci_postgresql_section_failure_probability_from_data_table\nOphalen faalkansen per dijkvak per moment\n\n\ninput_ci_postgresql_section_load_from_data_table\nOphalen tijdreeks van belasting per dijkvak\n\n\ninput_ci_postgresql_section_thresholds_from_conditions_table\nOphalen klassegrenzen (faalkans) van een dijkvak uit een continu database.\n\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_section.input_ci_postgresql_from_sectionfractions(\n    input_config\n)\nOphalen sections fractions uit een continu database.\nYaml example:\ntype: ci_postgresql_from_sectionfractions\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nid: int64 : id van de dijkvak\nidup: int64 : id van bovenstrooms meetstation\niddown: int64 : id van benedestrooms meetstation\nfractionup: float64 : fractie van bovenstrooms meetstation\nfractiondown: float64 : fractie van benedestrooms meetstation\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_section.input_ci_postgresql_from_sections(\n    input_config\n)\nOphalen section data uit de Continu Inzicht database.\nYaml example:\ntype: ci_postgresql_from_sections\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nid: int64 : id van de dijkvak\nname: str : naam van de dijkvak\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_section.input_ci_postgresql_section_expert_judgement_table(\n    input_config\n)\nOphalen klassegrenzen (faalkans) van een dijkvak uit een continu database.\nYaml example:\ntype: ci_postgresql_section_thresholds_from_conditions_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nstate_id: int64 : id van de klassegrens\nlower_boundary: float64 : ondergrens van de klassegrens\nupper_boundary: float64 : bovengrens van de klassegrens\ncolor: str : kleur van de klassegrens\nlabel: str : legendanaam van de klassegrens\nunit: str : unit van de klassegrens\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_section.input_ci_postgresql_section_failure_probability_from_data_table(\n    input_config\n)\nOphalen faalkansen per dijkvak per moment\nYaml example:\ntype: ci_postgresql_section_failure_probability_from_data_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nfailureprobability_id: in64 : id van de dijkvak/faalmechanisme/maatregel combinatie\nsection_id: int64 : id van de dijkvak\nvalue_parameter_id: int64 : id van de belasting parameter (1/2/3/4)\nfailuremechanism_id: int64 : id van het faalmechanisme\nfailuremechanism: str : naam van het faalmechanisme\nmeasures_id: int64 : id van de maatregel\nmeasure: str : naam van de maatregel\nparameter_id: int64 : id van de faalkans parameter (5/100/101/102)\nunit: int64 : unit van de belasting\ndate_time: datetime64 : datum/ tijd van de tijdreeksitem\nvalue: float : waarde van de tijdreeksitem\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_section.input_ci_postgresql_section_load_from_data_table(\n    input_config\n)\nOphalen tijdreeks van belasting per dijkvak\nYaml example:\ntype: ci_postgresql_section_load_from_data_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nsection_id: int64 : id van de dijkvak\nparameter_id: int64 : id van de parameter\nunit: str : unit van de parameter\ndate_time: datetime64 : datum/ tijd van de tijdreeksitem\nvalue: float64 : waarde van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_section.input_ci_postgresql_section_thresholds_from_conditions_table(\n    input_config\n)\nOphalen klassegrenzen (faalkans) van een dijkvak uit een continu database.\nYaml example:\ntype: ci_postgresql_section_thresholds_from_conditions_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nstate_id: int64 : id van de klassegrens\nlower_boundary: float64 : ondergrens van de klassegrens\nupper_boundary: float64 : bovengrens van de klassegrens\ncolor: str : kleur van de klassegrens\nlabel: str : legendanaam van de klassegrens\nunit: str : unit van de klassegrens"
  },
  {
    "objectID": "reference/input_fragilitycurve.html",
    "href": "reference/input_fragilitycurve.html",
    "title": "input_fragilitycurve",
    "section": "",
    "text": "base.adapters.input.continu_inzicht_postgresql.input_fragilitycurve\nData adapters voor het lezen van data uit de Continu Inzicht database\n\n\n\n\n\nName\nDescription\n\n\n\n\ninput_ci_postgresql_bedlevelfetch\nleest bedlevelfetch data van postgresql database in de bedlevelfetch tabel & zet namen goed.\n\n\ninput_ci_postgresql_fragilitycurves\nleest fragility curves data van postgresql database in.\n\n\ninput_ci_postgresql_fragilitycurves_overtopping\nleest fragility curves data van postgresql database in , zet namen goed en filterd op overtopping.\n\n\ninput_ci_postgresql_fragilitycurves_piping\nleest fragility curves data van postgresql database in , zet namen goed en filterd op piping.\n\n\ninput_ci_postgresql_fragilitycurves_stability\nleest fragility curves data van postgresql database in , zet namen goed en filterd op piping.\n\n\ninput_ci_postgresql_fragilitycurves_table\nOphalen fragilitycurves voor alle dijkvakken, faalmechanismes en opgegeven maatregel\n\n\ninput_ci_postgresql_measure_fragilitycurves_table\nOphalen fragilitycurves voor alle dijkvakken, faalmechanismes en maatregelen\n\n\ninput_ci_postgresql_probablistic_piping\nleest probablistic data van postgresql database in de probablistic piping tabel en hernoemt de kollomen.\n\n\ninput_ci_postgresql_profiles\nleest profile data van postgresql database in de profile tabel & zet namen goed.\n\n\ninput_ci_postgresql_slopes\nleest slopes data van postgresql database in de slopes tabel & zet namen goed.\n\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_bedlevelfetch(\n    input_config\n)\nleest bedlevelfetch data van postgresql database in de bedlevelfetch tabel & zet namen goed.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_fragilitycurves(\n    input_config\n)\nleest fragility curves data van postgresql database in.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_fragilitycurves_overtopping(\n    input_config\n)\nleest fragility curves data van postgresql database in , zet namen goed en filterd op overtopping.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_fragilitycurves_piping(\n    input_config\n)\nleest fragility curves data van postgresql database in , zet namen goed en filterd op piping.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_fragilitycurves_stability(\n    input_config\n)\nleest fragility curves data van postgresql database in , zet namen goed en filterd op piping.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_fragilitycurves_table(\n    input_config\n)\nOphalen fragilitycurves voor alle dijkvakken, faalmechanismes en opgegeven maatregel\nYaml example:\ntype: ci_postgresql_fragilitycurves_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nmeasureid: 0\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\nmeasureid (int64, optioneel): maatregel id, bij geen waarde wordt geen maatregel (measureid=0) gebruikt\ntimedep (int64, optioneel): tijdsafhankelijk 0=nee, 1=ja\ndegradatieid (int64, optioneel): rekening houden met degradatie (nog net geimplementeerd)\n\nReturns:\ndf (DataFrame):\n\nsection_id: int64 : id van de dijkvak\nmeasure_id: int64 : id van de maatregel\nmeasure: str : naam van de maatregel\nfailuremechanismid: int64 : id van het faalmechanisme\nfailuremechanism: str : naam van het faalmechanisme\nhydraulicload: float64 : belasting van de tijdreeksitem\nfailureprobability: float64 : faalkans van de tijdreeksitem\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_measure_fragilitycurves_table(\n    input_config\n)\nOphalen fragilitycurves voor alle dijkvakken, faalmechanismes en maatregelen\nYaml example:\ntype: ci_postgresql_measure_fragilitycurves_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\ntimedep (int64, optioneel): tijdsafhankelijk 0=nee, 1=ja\ndegradatieid (int64, optioneel): rekening houden met degradatie (nog net geimplementeerd)\n\nReturns:\ndf (DataFrame):\n\nsection_id: int64 : id van de dijkvak\nmeasure_id: int64 : id van de maatregel\nmeasure: str : naam van de maatregel\nfailuremechanismid: int64 : id van het faalmechanisme\nfailuremechanism: str : naam van het faalmechanisme\nhydraulicload: float64 : belasting van de tijdreeksitem\nfailureprobability: float64 : faalkans van de tijdreeksitem\nsuccessrate: float64 : kans op succes van de maatregel\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_probablistic_piping(\n    input_config\n)\nleest probablistic data van postgresql database in de probablistic piping tabel en hernoemt de kollomen.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_profiles(\n    input_config\n)\nleest profile data van postgresql database in de profile tabel & zet namen goed.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_slopes(\n    input_config\n)\nleest slopes data van postgresql database in de slopes tabel & zet namen goed."
  },
  {
    "objectID": "reference/input_fragilitycurve.html#functions",
    "href": "reference/input_fragilitycurve.html#functions",
    "title": "input_fragilitycurve",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ninput_ci_postgresql_bedlevelfetch\nleest bedlevelfetch data van postgresql database in de bedlevelfetch tabel & zet namen goed.\n\n\ninput_ci_postgresql_fragilitycurves\nleest fragility curves data van postgresql database in.\n\n\ninput_ci_postgresql_fragilitycurves_overtopping\nleest fragility curves data van postgresql database in , zet namen goed en filterd op overtopping.\n\n\ninput_ci_postgresql_fragilitycurves_piping\nleest fragility curves data van postgresql database in , zet namen goed en filterd op piping.\n\n\ninput_ci_postgresql_fragilitycurves_stability\nleest fragility curves data van postgresql database in , zet namen goed en filterd op piping.\n\n\ninput_ci_postgresql_fragilitycurves_table\nOphalen fragilitycurves voor alle dijkvakken, faalmechanismes en opgegeven maatregel\n\n\ninput_ci_postgresql_measure_fragilitycurves_table\nOphalen fragilitycurves voor alle dijkvakken, faalmechanismes en maatregelen\n\n\ninput_ci_postgresql_probablistic_piping\nleest probablistic data van postgresql database in de probablistic piping tabel en hernoemt de kollomen.\n\n\ninput_ci_postgresql_profiles\nleest profile data van postgresql database in de profile tabel & zet namen goed.\n\n\ninput_ci_postgresql_slopes\nleest slopes data van postgresql database in de slopes tabel & zet namen goed.\n\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_bedlevelfetch(\n    input_config\n)\nleest bedlevelfetch data van postgresql database in de bedlevelfetch tabel & zet namen goed.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_fragilitycurves(\n    input_config\n)\nleest fragility curves data van postgresql database in.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_fragilitycurves_overtopping(\n    input_config\n)\nleest fragility curves data van postgresql database in , zet namen goed en filterd op overtopping.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_fragilitycurves_piping(\n    input_config\n)\nleest fragility curves data van postgresql database in , zet namen goed en filterd op piping.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_fragilitycurves_stability(\n    input_config\n)\nleest fragility curves data van postgresql database in , zet namen goed en filterd op piping.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_fragilitycurves_table(\n    input_config\n)\nOphalen fragilitycurves voor alle dijkvakken, faalmechanismes en opgegeven maatregel\nYaml example:\ntype: ci_postgresql_fragilitycurves_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nmeasureid: 0\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\nmeasureid (int64, optioneel): maatregel id, bij geen waarde wordt geen maatregel (measureid=0) gebruikt\ntimedep (int64, optioneel): tijdsafhankelijk 0=nee, 1=ja\ndegradatieid (int64, optioneel): rekening houden met degradatie (nog net geimplementeerd)\n\nReturns:\ndf (DataFrame):\n\nsection_id: int64 : id van de dijkvak\nmeasure_id: int64 : id van de maatregel\nmeasure: str : naam van de maatregel\nfailuremechanismid: int64 : id van het faalmechanisme\nfailuremechanism: str : naam van het faalmechanisme\nhydraulicload: float64 : belasting van de tijdreeksitem\nfailureprobability: float64 : faalkans van de tijdreeksitem\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_measure_fragilitycurves_table(\n    input_config\n)\nOphalen fragilitycurves voor alle dijkvakken, faalmechanismes en maatregelen\nYaml example:\ntype: ci_postgresql_measure_fragilitycurves_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\ntimedep (int64, optioneel): tijdsafhankelijk 0=nee, 1=ja\ndegradatieid (int64, optioneel): rekening houden met degradatie (nog net geimplementeerd)\n\nReturns:\ndf (DataFrame):\n\nsection_id: int64 : id van de dijkvak\nmeasure_id: int64 : id van de maatregel\nmeasure: str : naam van de maatregel\nfailuremechanismid: int64 : id van het faalmechanisme\nfailuremechanism: str : naam van het faalmechanisme\nhydraulicload: float64 : belasting van de tijdreeksitem\nfailureprobability: float64 : faalkans van de tijdreeksitem\nsuccessrate: float64 : kans op succes van de maatregel\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_probablistic_piping(\n    input_config\n)\nleest probablistic data van postgresql database in de probablistic piping tabel en hernoemt de kollomen.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_profiles(\n    input_config\n)\nleest profile data van postgresql database in de profile tabel & zet namen goed.\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_fragilitycurve.input_ci_postgresql_slopes(\n    input_config\n)\nleest slopes data van postgresql database in de slopes tabel & zet namen goed."
  },
  {
    "objectID": "reference/get_waterinfo_thresholds.html",
    "href": "reference/get_waterinfo_thresholds.html",
    "title": "get_waterinfo_thresholds",
    "section": "",
    "text": "get_waterinfo_thresholds\nloads.get_waterinfo_thresholds(location_code, parameter_id='waterhoogte')\nHaal voor Waterinfo de thresholds op voor de opgegegeven parameter.\nArgs: parameter_id (str): Waterinfo parameter bij geen waarde ‘waterhoogte’\nReturns: Dataframe: Pandas dataframe met thressholds"
  },
  {
    "objectID": "reference/get_rws_webservices_locations.html",
    "href": "reference/get_rws_webservices_locations.html",
    "title": "get_rws_webservices_locations",
    "section": "",
    "text": "get_rws_webservices_locations\nloads.get_rws_webservices_locations()\nHaal locaties op die bekend zijn bij de RWS webservice."
  },
  {
    "objectID": "reference/get_fews_thresholds.html",
    "href": "reference/get_fews_thresholds.html",
    "title": "get_fews_thresholds",
    "section": "",
    "text": "get_fews_thresholds\nloads.get_fews_thresholds(\n    host\n    port\n    region\n    filter_id\n    parameter_id\n    location_id\n)\nHaal voor Fews de thresholds op voor de opgegegeven parameter en locatie.\nArgs: host (str): fews server host url port (int): port waar de restservice draait region (str): in fews gedefinieerde region filter_id (str): filter van de timeserie parameter_id (str): parameter van de timeserie locatie_id (str): locatie van de timeserie\nReturns: Dataframe: Pandas dataframe met thresholds"
  },
  {
    "objectID": "reference/FragilityCurvesPiping.html",
    "href": "reference/FragilityCurvesPiping.html",
    "title": "FragilityCurvesPiping",
    "section": "",
    "text": "fragility_curves.FragilityCurvesPiping()\nMaakt een set van fragility curves voor piping voor een dijkvak. De fragility curve wordt berekend met behulp van de probabilistic_piping package, zie de eigen documentatie voor meer informatie.\nDeze functie berekent ��n gecombineerde fragility curves voor mechanismes: uplift, heave, Sellmeijer.\nArgs: data_adapter (DataAdapter): DataAdapter object\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\ndf_prob_input\n\n\n\ndf_waterlevels\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfragility_curve_function_simple\nMaakt een enkele fragility curve voor piping met een gegeven waterstand.\n\n\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple()\nMaakt een enkele fragility curve voor piping met een gegeven waterstand.\nDe fragility curve wordt berekend met behulp van de probabilistic_piping package, zie de eigen documentatie voor meer informatie. Deze functie berekent fragility curves voor uplift, heave, Sellmeijer, en de gecombineerde mechanismes. Voor het combineren van de mechanismes wordt het minimum van de kansen van de drie sub-mechanismes genomen, De gecombineerde fragility curve is de standaard output, de andere kunnen worden opgevraagd met de df_result_uplift, df_result_heave, en df_result_sellmeijer attributen.\nArgs: data_adapter (DataAdapter): DataAdapter object\n\n\nprogress: bool Standaard is False\ndebug: bool Standaard is False\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\ndf_prob_input\n\n\n\ndf_result_combined\n\n\n\ndf_result_heave\n\n\n\ndf_result_sellmeijer\n\n\n\ndf_result_uplift\n\n\n\ndf_waterlevels\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor piping\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple.as_array(\n)\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple.load(\n    input\n)\nLaad een fragility curve in\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple.refine(\n    waterlevels\n)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple.run(\n    input\n    output\n)\nRunt de berekening van de fragility curve voor piping\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_prob_input (pd.DataFrame), [1] df_waterlevels (pd.DataFrame),\nrequired\n\n\noutput\nstr\nFragility curve (pd.DataFrame)\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_prob_input (pd.DataFrame)\n\n        DataFrame met data voor de probabilistische berekening.\n        De benodigde kolommen zijn afhankelijk van de probabilistische berekening.\n        Zie de documentatie van probabilistic_piping.probabilistic_fixedwl.ProbPipingFixedWaterlevelSimple voor meer informatie.\n\n\n   [1] df_waterlevels (pd.DataFrame):\n        DataFrame met waterlevel data.\n        Moet de volgende kolommen bevatten:\n        - waterlevels : float\n\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple.shift(\n    effect\n)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun\nRunt de berekening van de fragility curves voor piping\n\n\n\n\n\nfragility_curves.FragilityCurvesPiping.run(input, output)\nRunt de berekening van de fragility curves voor piping\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_prob_input (pd.DataFrame), [1] df_waterlevels (pd.DataFrame),\nrequired\n\n\noutput\nstr\nFragility curves (pd.DataFrame)\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_prob_input (pd.DataFrame)\n\n        DataFrame met data voor de probabilistische berekening.\n        De benodigde kolommen zijn afhankelijk van de probabilistische berekening.\n        Zie de documentatie van probabilistic_piping.probabilistic_fixedwl.ProbPipingFixedWaterlevel voor meer informatie.\n\n\n   [1] df_waterlevels (pd.DataFrame):\n        DataFrame met waterlevel data.\n        Moet de volgende kolommen bevatten:\n        - waterlevels : float"
  },
  {
    "objectID": "reference/FragilityCurvesPiping.html#attributes",
    "href": "reference/FragilityCurvesPiping.html#attributes",
    "title": "FragilityCurvesPiping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\ndf_prob_input\n\n\n\ndf_waterlevels"
  },
  {
    "objectID": "reference/FragilityCurvesPiping.html#classes",
    "href": "reference/FragilityCurvesPiping.html#classes",
    "title": "FragilityCurvesPiping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfragility_curve_function_simple\nMaakt een enkele fragility curve voor piping met een gegeven waterstand.\n\n\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple()\nMaakt een enkele fragility curve voor piping met een gegeven waterstand.\nDe fragility curve wordt berekend met behulp van de probabilistic_piping package, zie de eigen documentatie voor meer informatie. Deze functie berekent fragility curves voor uplift, heave, Sellmeijer, en de gecombineerde mechanismes. Voor het combineren van de mechanismes wordt het minimum van de kansen van de drie sub-mechanismes genomen, De gecombineerde fragility curve is de standaard output, de andere kunnen worden opgevraagd met de df_result_uplift, df_result_heave, en df_result_sellmeijer attributen.\nArgs: data_adapter (DataAdapter): DataAdapter object\n\n\nprogress: bool Standaard is False\ndebug: bool Standaard is False\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\ndf_prob_input\n\n\n\ndf_result_combined\n\n\n\ndf_result_heave\n\n\n\ndf_result_sellmeijer\n\n\n\ndf_result_uplift\n\n\n\ndf_waterlevels\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor piping\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple.as_array(\n)\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple.load(\n    input\n)\nLaad een fragility curve in\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple.refine(\n    waterlevels\n)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple.run(\n    input\n    output\n)\nRunt de berekening van de fragility curve voor piping\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_prob_input (pd.DataFrame), [1] df_waterlevels (pd.DataFrame),\nrequired\n\n\noutput\nstr\nFragility curve (pd.DataFrame)\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_prob_input (pd.DataFrame)\n\n        DataFrame met data voor de probabilistische berekening.\n        De benodigde kolommen zijn afhankelijk van de probabilistische berekening.\n        Zie de documentatie van probabilistic_piping.probabilistic_fixedwl.ProbPipingFixedWaterlevelSimple voor meer informatie.\n\n\n   [1] df_waterlevels (pd.DataFrame):\n        DataFrame met waterlevel data.\n        Moet de volgende kolommen bevatten:\n        - waterlevels : float\n\n\n\n\nfragility_curves.FragilityCurvesPiping.fragility_curve_function_simple.shift(\n    effect\n)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "reference/FragilityCurvesPiping.html#methods-1",
    "href": "reference/FragilityCurvesPiping.html#methods-1",
    "title": "FragilityCurvesPiping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrun\nRunt de berekening van de fragility curves voor piping\n\n\n\n\n\nfragility_curves.FragilityCurvesPiping.run(input, output)\nRunt de berekening van de fragility curves voor piping\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_prob_input (pd.DataFrame), [1] df_waterlevels (pd.DataFrame),\nrequired\n\n\noutput\nstr\nFragility curves (pd.DataFrame)\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_prob_input (pd.DataFrame)\n\n        DataFrame met data voor de probabilistische berekening.\n        De benodigde kolommen zijn afhankelijk van de probabilistische berekening.\n        Zie de documentatie van probabilistic_piping.probabilistic_fixedwl.ProbPipingFixedWaterlevel voor meer informatie.\n\n\n   [1] df_waterlevels (pd.DataFrame):\n        DataFrame met waterlevel data.\n        Moet de volgende kolommen bevatten:\n        - waterlevels : float"
  },
  {
    "objectID": "reference/FragilityCurvePipingFixedWaterlevelSimple.html",
    "href": "reference/FragilityCurvePipingFixedWaterlevelSimple.html",
    "title": "FragilityCurvePipingFixedWaterlevelSimple",
    "section": "",
    "text": "fragility_curves.FragilityCurvePipingFixedWaterlevelSimple()\nMaakt een enkele fragility curve voor piping met een gegeven waterstand.\nDe fragility curve wordt berekend met behulp van de probabilistic_piping package, zie de eigen documentatie voor meer informatie. Deze functie berekent fragility curves voor uplift, heave, Sellmeijer, en de gecombineerde mechanismes. Voor het combineren van de mechanismes wordt het minimum van de kansen van de drie sub-mechanismes genomen, De gecombineerde fragility curve is de standaard output, de andere kunnen worden opgevraagd met de df_result_uplift, df_result_heave, en df_result_sellmeijer attributen.\nArgs: data_adapter (DataAdapter): DataAdapter object\n\n\nprogress: bool Standaard is False\ndebug: bool Standaard is False\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\ndf_prob_input\n\n\n\ndf_result_combined\n\n\n\ndf_result_heave\n\n\n\ndf_result_sellmeijer\n\n\n\ndf_result_uplift\n\n\n\ndf_waterlevels\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor piping\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.FragilityCurvePipingFixedWaterlevelSimple.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.FragilityCurvePipingFixedWaterlevelSimple.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\n\nfragility_curves.FragilityCurvePipingFixedWaterlevelSimple.load(input)\nLaad een fragility curve in\n\n\n\nfragility_curves.FragilityCurvePipingFixedWaterlevelSimple.refine(waterlevels)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.FragilityCurvePipingFixedWaterlevelSimple.run(input, output)\nRunt de berekening van de fragility curve voor piping\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_prob_input (pd.DataFrame), [1] df_waterlevels (pd.DataFrame),\nrequired\n\n\noutput\nstr\nFragility curve (pd.DataFrame)\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_prob_input (pd.DataFrame)\n\n        DataFrame met data voor de probabilistische berekening.\n        De benodigde kolommen zijn afhankelijk van de probabilistische berekening.\n        Zie de documentatie van probabilistic_piping.probabilistic_fixedwl.ProbPipingFixedWaterlevelSimple voor meer informatie.\n\n\n   [1] df_waterlevels (pd.DataFrame):\n        DataFrame met waterlevel data.\n        Moet de volgende kolommen bevatten:\n        - waterlevels : float\n\n\n\n\nfragility_curves.FragilityCurvePipingFixedWaterlevelSimple.shift(effect)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "reference/FragilityCurvePipingFixedWaterlevelSimple.html#options-in-config",
    "href": "reference/FragilityCurvePipingFixedWaterlevelSimple.html#options-in-config",
    "title": "FragilityCurvePipingFixedWaterlevelSimple",
    "section": "",
    "text": "progress: bool Standaard is False\ndebug: bool Standaard is False"
  },
  {
    "objectID": "reference/FragilityCurvePipingFixedWaterlevelSimple.html#attributes",
    "href": "reference/FragilityCurvePipingFixedWaterlevelSimple.html#attributes",
    "title": "FragilityCurvePipingFixedWaterlevelSimple",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\ndf_prob_input\n\n\n\ndf_result_combined\n\n\n\ndf_result_heave\n\n\n\ndf_result_sellmeijer\n\n\n\ndf_result_uplift\n\n\n\ndf_waterlevels\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary"
  },
  {
    "objectID": "reference/FragilityCurvePipingFixedWaterlevelSimple.html#methods",
    "href": "reference/FragilityCurvePipingFixedWaterlevelSimple.html#methods",
    "title": "FragilityCurvePipingFixedWaterlevelSimple",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor piping\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.FragilityCurvePipingFixedWaterlevelSimple.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.FragilityCurvePipingFixedWaterlevelSimple.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\n\nfragility_curves.FragilityCurvePipingFixedWaterlevelSimple.load(input)\nLaad een fragility curve in\n\n\n\nfragility_curves.FragilityCurvePipingFixedWaterlevelSimple.refine(waterlevels)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.FragilityCurvePipingFixedWaterlevelSimple.run(input, output)\nRunt de berekening van de fragility curve voor piping\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_prob_input (pd.DataFrame), [1] df_waterlevels (pd.DataFrame),\nrequired\n\n\noutput\nstr\nFragility curve (pd.DataFrame)\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_prob_input (pd.DataFrame)\n\n        DataFrame met data voor de probabilistische berekening.\n        De benodigde kolommen zijn afhankelijk van de probabilistische berekening.\n        Zie de documentatie van probabilistic_piping.probabilistic_fixedwl.ProbPipingFixedWaterlevelSimple voor meer informatie.\n\n\n   [1] df_waterlevels (pd.DataFrame):\n        DataFrame met waterlevel data.\n        Moet de volgende kolommen bevatten:\n        - waterlevels : float\n\n\n\n\nfragility_curves.FragilityCurvePipingFixedWaterlevelSimple.shift(effect)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "reference/FragilityCurve.html",
    "href": "reference/FragilityCurve.html",
    "title": "FragilityCurve",
    "section": "",
    "text": "FragilityCurve()\nClass met een aantal gemakkelijke methoden om fragility curves op te slaan en aan te passen\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\n\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\n\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nFragilityCurve.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nFragilityCurve.calculate_fragility_curve(*args, **kwargs)\n\n\n\nFragilityCurve.load(input)\nLaad een fragility curve in\n\n\n\nFragilityCurve.refine(waterlevels)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nFragilityCurve.run(*args, **kwargs)\n\n\n\nFragilityCurve.shift(effect)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "reference/FragilityCurve.html#attributes",
    "href": "reference/FragilityCurve.html#attributes",
    "title": "FragilityCurve",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary"
  },
  {
    "objectID": "reference/FragilityCurve.html#methods",
    "href": "reference/FragilityCurve.html#methods",
    "title": "FragilityCurve",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\n\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\n\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nFragilityCurve.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nFragilityCurve.calculate_fragility_curve(*args, **kwargs)\n\n\n\nFragilityCurve.load(input)\nLaad een fragility curve in\n\n\n\nFragilityCurve.refine(waterlevels)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nFragilityCurve.run(*args, **kwargs)\n\n\n\nFragilityCurve.shift(effect)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "reference/Config.html",
    "href": "reference/Config.html",
    "title": "Config",
    "section": "",
    "text": "Config()\nBasis functie om de configuratie in te laden.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nconfig_path\n\nPad naar een .yaml bestand waarin per functie staat beschreven wat de in/ouput bestanden zijn\nrequired\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nconfig_path\n\n\n\ndata_adapters\n\n\n\nglobal_variables\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninit_data_adapters\n\n\n\nlees_config\nLaad het gegeven pad in, zet de configuraties klaar in de Config class\n\n\n\n\n\nConfig.init_data_adapters()\n\n\n\nConfig.lees_config()\nLaad het gegeven pad in, zet de configuraties klaar in de Config class"
  },
  {
    "objectID": "reference/Config.html#parameters",
    "href": "reference/Config.html#parameters",
    "title": "Config",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nconfig_path\n\nPad naar een .yaml bestand waarin per functie staat beschreven wat de in/ouput bestanden zijn\nrequired"
  },
  {
    "objectID": "reference/Config.html#attributes",
    "href": "reference/Config.html#attributes",
    "title": "Config",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconfig_path\n\n\n\ndata_adapters\n\n\n\nglobal_variables"
  },
  {
    "objectID": "reference/Config.html#methods",
    "href": "reference/Config.html#methods",
    "title": "Config",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ninit_data_adapters\n\n\n\nlees_config\nLaad het gegeven pad in, zet de configuraties klaar in de Config class\n\n\n\n\n\nConfig.init_data_adapters()\n\n\n\nConfig.lees_config()\nLaad het gegeven pad in, zet de configuraties klaar in de Config class"
  },
  {
    "objectID": "reference/CombineFragilityCurvesIndependent.html",
    "href": "reference/CombineFragilityCurvesIndependent.html",
    "title": "CombineFragilityCurvesIndependent",
    "section": "",
    "text": "fragility_curves.CombineFragilityCurvesIndependent()\nCombineer meerdere fragility curves onafhankelijk tot een enkele fragility curves.\nArgs: data_adapter (DataAdapter): DataAdapter object\n\n\nBij het combineren van de fragility curves moeten de waterstanden van de curves op elkaar afgestemd worden. Dit gebeurt door de waterstanden van de curves te interpoleren naar een nieuwe set waterstanden. De volgende opties kunnen worden ingesteld: - extend_past_max: float Hoever de nieuwe waterstanden verder gaan dan de maximale waterstanden van de input curves. Default is 0.01\n\nrefine_step_size: float De stapgrootte van de waterstanden die gebruikt wordt bij het herschalen van de kansen voor het combineren. Default is 0.05\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\nlst_fragility_curves\n\n\n\nweights\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalculate_combined_curve\n\n\n\ncombine_func\nCombineer onafhankelijk: P(fail,comb|h) = 1 - PROD(1 - P(fail,i|h))\n\n\nrun\n\n\n\n\n\n\nfragility_curves.CombineFragilityCurvesIndependent.calculate_combined_curve(\n    extend_past_max\n    refine_step_size\n)\n\n\n\nfragility_curves.CombineFragilityCurvesIndependent.combine_func(\n    lst_fragility_curves\n    **kwargs\n)\nCombineer onafhankelijk: P(fail,comb|h) = 1 - PROD(1 - P(fail,i|h))\n\n\n\nfragility_curves.CombineFragilityCurvesIndependent.run(input, output)\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\nLijst van namen van de data adapters met fragility curves.\nrequired\n\n\noutput\nstr\nNaam van de output data adapter.\nrequired\n\n\n\n\n\n\nElke fragility curve moet de volgende kolommen bevatten: - waterlevels: float - failure_probabilities: float"
  },
  {
    "objectID": "reference/CombineFragilityCurvesIndependent.html#options-in-config",
    "href": "reference/CombineFragilityCurvesIndependent.html#options-in-config",
    "title": "CombineFragilityCurvesIndependent",
    "section": "",
    "text": "Bij het combineren van de fragility curves moeten de waterstanden van de curves op elkaar afgestemd worden. Dit gebeurt door de waterstanden van de curves te interpoleren naar een nieuwe set waterstanden. De volgende opties kunnen worden ingesteld: - extend_past_max: float Hoever de nieuwe waterstanden verder gaan dan de maximale waterstanden van de input curves. Default is 0.01\n\nrefine_step_size: float De stapgrootte van de waterstanden die gebruikt wordt bij het herschalen van de kansen voor het combineren. Default is 0.05"
  },
  {
    "objectID": "reference/CombineFragilityCurvesIndependent.html#attributes",
    "href": "reference/CombineFragilityCurvesIndependent.html#attributes",
    "title": "CombineFragilityCurvesIndependent",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\nlst_fragility_curves\n\n\n\nweights"
  },
  {
    "objectID": "reference/CombineFragilityCurvesIndependent.html#methods",
    "href": "reference/CombineFragilityCurvesIndependent.html#methods",
    "title": "CombineFragilityCurvesIndependent",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncalculate_combined_curve\n\n\n\ncombine_func\nCombineer onafhankelijk: P(fail,comb|h) = 1 - PROD(1 - P(fail,i|h))\n\n\nrun\n\n\n\n\n\n\nfragility_curves.CombineFragilityCurvesIndependent.calculate_combined_curve(\n    extend_past_max\n    refine_step_size\n)\n\n\n\nfragility_curves.CombineFragilityCurvesIndependent.combine_func(\n    lst_fragility_curves\n    **kwargs\n)\nCombineer onafhankelijk: P(fail,comb|h) = 1 - PROD(1 - P(fail,i|h))\n\n\n\nfragility_curves.CombineFragilityCurvesIndependent.run(input, output)\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\nLijst van namen van de data adapters met fragility curves.\nrequired\n\n\noutput\nstr\nNaam van de output data adapter.\nrequired\n\n\n\n\n\n\nElke fragility curve moet de volgende kolommen bevatten: - waterlevels: float - failure_probabilities: float"
  },
  {
    "objectID": "reference/ChangeCrestHeightFragilityCurveOvertopping.html",
    "href": "reference/ChangeCrestHeightFragilityCurveOvertopping.html",
    "title": "ChangeCrestHeightFragilityCurveOvertopping",
    "section": "",
    "text": "fragility_curves.ChangeCrestHeightFragilityCurveOvertopping()\nVerschuift de kruin hoogte met het gegeven effect en berekent de fragility curve\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_bed_levels\n\n\n\ndf_out\n\n\n\ndf_slopes\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor golf overslag & past de kruinhoogte aan met een gegeven effect\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.ChangeCrestHeightFragilityCurveOvertopping.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.ChangeCrestHeightFragilityCurveOvertopping.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand. Parameters: input (list[str]): Een lijst met de bestandsnamen van de inputbestanden. output (str): De bestandsnaam waarin het resultaat moet worden opgeslagen. Returns: None\n\n\n\nfragility_curves.ChangeCrestHeightFragilityCurveOvertopping.load(input)\nLaad een fragility curve in\n\n\n\nfragility_curves.ChangeCrestHeightFragilityCurveOvertopping.refine(waterlevels)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.ChangeCrestHeightFragilityCurveOvertopping.run(\n    input\n    output\n    effect\n)\nRunt de berekening van de fragility curve voor golf overslag & past de kruinhoogte aan met een gegeven effect\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_slopes (pd.DataFrame), [1] df_profile (pd.DataFrame), [2] df_bed_levels (pd.DataFrame)\nrequired\n\n\noutput\nstr\nFragility curve output\nrequired\n\n\neffect\nfloat\nVerschuiving van de kruinhoogte (in meters)\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_slopes (pd.DataFrame)\n\n        DataFrame met helling data.\n        Moet de volgende kolommen bevatten:\n        - x : float\n        - y : float\n        - r : float\n        - slopetypeid : int (1: dike or 2: slope)\n\n   [1] df_profile (pd.DataFrame):\n        DataFrame met profiel data.\n        Moet de volgende kolommen bevatten:\n        - windspeed : float\n        - sectormin : float\n        - sectorsize : float\n        - orientation : float (in graden)\n        - crestlevel : float (in meters)\n        - dam : int (0: geen dam or 1: dam)\n        - damheight : float (in meters)\n        - qcr : float (waarde in m^3/s)\n            str (close | open)\n            tuple (waarden van mu en sigma)\n\n   [2] df_bed_levels (pd.DataFrame):\n        DataFrame met bed level data.\n        Moet de volgende kolommen bevatten:\n        - direction : float\n        - bedlevel : float\n        - fetch : float\n\n\n\n\nfragility_curves.ChangeCrestHeightFragilityCurveOvertopping.shift(effect)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "reference/ChangeCrestHeightFragilityCurveOvertopping.html#attributes",
    "href": "reference/ChangeCrestHeightFragilityCurveOvertopping.html#attributes",
    "title": "ChangeCrestHeightFragilityCurveOvertopping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_bed_levels\n\n\n\ndf_out\n\n\n\ndf_slopes\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary"
  },
  {
    "objectID": "reference/ChangeCrestHeightFragilityCurveOvertopping.html#methods",
    "href": "reference/ChangeCrestHeightFragilityCurveOvertopping.html#methods",
    "title": "ChangeCrestHeightFragilityCurveOvertopping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor golf overslag & past de kruinhoogte aan met een gegeven effect\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.ChangeCrestHeightFragilityCurveOvertopping.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.ChangeCrestHeightFragilityCurveOvertopping.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand. Parameters: input (list[str]): Een lijst met de bestandsnamen van de inputbestanden. output (str): De bestandsnaam waarin het resultaat moet worden opgeslagen. Returns: None\n\n\n\nfragility_curves.ChangeCrestHeightFragilityCurveOvertopping.load(input)\nLaad een fragility curve in\n\n\n\nfragility_curves.ChangeCrestHeightFragilityCurveOvertopping.refine(waterlevels)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.ChangeCrestHeightFragilityCurveOvertopping.run(\n    input\n    output\n    effect\n)\nRunt de berekening van de fragility curve voor golf overslag & past de kruinhoogte aan met een gegeven effect\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_slopes (pd.DataFrame), [1] df_profile (pd.DataFrame), [2] df_bed_levels (pd.DataFrame)\nrequired\n\n\noutput\nstr\nFragility curve output\nrequired\n\n\neffect\nfloat\nVerschuiving van de kruinhoogte (in meters)\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_slopes (pd.DataFrame)\n\n        DataFrame met helling data.\n        Moet de volgende kolommen bevatten:\n        - x : float\n        - y : float\n        - r : float\n        - slopetypeid : int (1: dike or 2: slope)\n\n   [1] df_profile (pd.DataFrame):\n        DataFrame met profiel data.\n        Moet de volgende kolommen bevatten:\n        - windspeed : float\n        - sectormin : float\n        - sectorsize : float\n        - orientation : float (in graden)\n        - crestlevel : float (in meters)\n        - dam : int (0: geen dam or 1: dam)\n        - damheight : float (in meters)\n        - qcr : float (waarde in m^3/s)\n            str (close | open)\n            tuple (waarden van mu en sigma)\n\n   [2] df_bed_levels (pd.DataFrame):\n        DataFrame met bed level data.\n        Moet de volgende kolommen bevatten:\n        - direction : float\n        - bedlevel : float\n        - fetch : float\n\n\n\n\nfragility_curves.ChangeCrestHeightFragilityCurveOvertopping.shift(effect)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "modules/kansen_en_status_per_sectie.html",
    "href": "modules/kansen_en_status_per_sectie.html",
    "title": "Conditionele kansen en status waterkering per sectie",
    "section": "",
    "text": "In ontwikkeling.",
    "crumbs": [
      "Modules",
      "Conditionele kansen en status waterkering per sectie"
    ]
  },
  {
    "objectID": "modules/effect_statistiek_rekenregels_LBO2.html",
    "href": "modules/effect_statistiek_rekenregels_LBO2.html",
    "title": "Zorgplicht LBO2: effect nieuwe statistiek en rekenregels op de faalkans",
    "section": "",
    "text": "In ontwikkeling.",
    "crumbs": [
      "Modules",
      "Zorgplicht LBO2: effect nieuwe statistiek en rekenregels op de faalkans"
    ]
  },
  {
    "objectID": "modules/bijstellen_fragility_curves.html",
    "href": "modules/bijstellen_fragility_curves.html",
    "title": "Bijstellen fragility curves",
    "section": "",
    "text": "Verschuiven van een curve\nVoor het simpel weg verschuiven van een curve is voor alle type fragility curves de functie Shift* beschikbaar, * de naam van de functie is. Zo schuift ShiftFragilityCurveOvertopping de curve van FragilityCurveOvertopping naar rechts met een gegeven effect. Belangrijk om hier te benoemen is dat de opties in GlobalVariables nog steeds moeten verwijzen naar de originele functie, ook alle andere configuraties blijven hetzelfde. In het voorbeeld hier onder wordt gebruik gemaakt vanFragilityCurveOvertopping in de GlobalVariables, ook al wordt de ShiftFragilityCurveOvertopping functie aangeroepen.\n\nConfiguratieCode\n\n\nGlobalVariables:\n    rootdir: \"data_sets\"\n\n    FragilityCurveOvertopping:\n        # default waardes, kunnen worden overschreven\n        gh_onz_mu: 0.96\n        gh_onz_sigma: 0.27\n        gp_onz_mu_tp: 1.03\n        gp_onz_sigma_tp: 0.13\n        gp_onz_mu_tspec: 1.03\n        gp_onz_sigma_tspec: 0.13\n        gh_onz_aantal: 7\n        gp_onz_aantal: 7\n        tp_tspec: 1.1\n        lower_limit_coarse: 4.0\n        upper_limit_coarse: 2.0\n        upper_limit_fine: 1.0\n        hstap: 0.05\n\nDataAdapter:\n    default_options:\n        csv:\n            sep: \",\"\n    slopes:\n        type: csv\n        file: \"slopes.csv\"\n    profiles:\n        type: csv\n        file: \"profiles.csv\"\n    bedlevel_fetch:\n        type: csv\n        file: \"bedlevelfetch.csv\"\n    fragility_curves:\n        type: csv\n        file: \"fragility_curves.csv\"\n\n\nfrom toolbox_continu_inzicht import Config, DataAdapter\nfrom toolbox_continu_inzicht.fragility_curves import ShiftFragilityCurveOvertopping\n\nconfig = Config(config_path=\"config.yaml\")\nconfig.lees_config()\ndata_adapter = DataAdapter(config=config)\nshifted_fragility_curve_overtopping = ShiftFragilityCurveOvertopping(data_adapter=data_adapter)\nshifted_fragility_curve_overtopping.run(\n    input=[\"slopes\", \"profiles\", \"bedlevel_fetch\"],\n    output=\"fragility_curves\",\n    effect=0.5\n)\n\n\n\n\n\nAanpassen van de kruinhoogte\nVoor het aanpassen van de kruinhoogte bij een GEKB is de functie ChangeCrestHeightFragilityCurveOvertopping beschikbaar, hier kan als effect mee gegeven worden wat de verandering van kruinhoogte is. De zelfde berekening als bij FragilityCurveOvertopping wordt dan uitgevoerd, maar met de aangepaste kruin hoogte.\n\nConfiguratieCode\n\n\nGlobalVariables:\n    rootdir: \"data_sets\"\n\n    FragilityCurveOvertopping:\n        # default waardes, kunnen worden overschreven\n        gh_onz_mu: 0.96\n        gh_onz_sigma: 0.27\n        gp_onz_mu_tp: 1.03\n        gp_onz_sigma_tp: 0.13\n        gp_onz_mu_tspec: 1.03\n        gp_onz_sigma_tspec: 0.13\n        gh_onz_aantal: 7\n        gp_onz_aantal: 7\n        tp_tspec: 1.1\n        lower_limit_coarse: 4.0\n        upper_limit_coarse: 2.0\n        upper_limit_fine: 1.0\n        hstap: 0.05\n\nDataAdapter:\n    default_options:\n        csv:\n            sep: \",\"\n    slopes:\n        type: csv\n        file: \"slopes.csv\"\n    profiles:\n        type: csv\n        file: \"profiles.csv\"\n    bedlevel_fetch:\n        type: csv\n        file: \"bedlevelfetch.csv\"\n    fragility_curves:\n        type: csv\n        file: \"fragility_curves.csv\"\n\n\nfrom toolbox_continu_inzicht import Config, DataAdapter\nfrom toolbox_continu_inzicht.fragility_curves import ChangeCrestHeightFragilityCurveOvertopping\n\nconfig = Config(config_path=\"config.yaml\")\nconfig.lees_config()\ndata_adapter = DataAdapter(config=config)\nchange_crest_fragility_curve_overtopping = ChangeCrestHeightFragilityCurveOvertopping(data_adapter=data_adapter)\nchange_crest_fragility_curve_overtopping.run(\n    input=[\"slopes\", \"profiles\", \"bedlevel_fetch\"],\n    output=\"fragility_curves\",\n    effect=1\n)",
    "crumbs": [
      "Modules",
      "Bijstellen fragility curves"
    ]
  },
  {
    "objectID": "modules/belastingen.html",
    "href": "modules/belastingen.html",
    "title": "Belastingen inlezen en classificeren",
    "section": "",
    "text": "Om inzicht te krijgen in de veiligheid van waterkeringen is het van belang om de belastingen op de waterkeringen in kaart te brengen. Dit kunnen waterstanden op het buitenwater (zee, rivieren of meren) zijn, maar ook grondwaterstanden. De belastingen worden eerst ingelezen uit verschillende databronnen en vervolgens geclassificeerd. De belastingen worden ingelezen voor verschillende momenten (bijv. gister, nu, morgen of overmorgen etc.), zodat naast metingen ook voorspellingen van belastingen worden ingelezen.\n\nBelastingen inlezen\nDe volgende databronnen worden op dit moment in de Toolbox Continu Inzicht ondersteund:\n\nDelft-FEWS\n(Noos)Matroos\nRWS waterwebservices\nRWS waterinfo\n\n\nDelft-FEWS\nVeel waterschappen gebruiken een Delft - Forecast Early Warning System (FEWS) implementatie voor het beheren van verschillende interne en externe informatiebronnen. Via de REST API van FEWS kunnen verschillende belastingen worden ingelezen. Toegang verkrijgen tot een FEWS is complexer dan andere bronnen, waardoor het noodzakelijk is om extra parameters te definiëren in het configuratiebestand. De functie get_fews_locations() kan worden gebruikt om de beschikbare locaties te tonen.\nGlobalVariables:\n    rootdir: \"data_sets\"  \n    moments: [-24,0,24,48]\n\n\n    LoadsFews:\n        host: \"https:**********\"\n        port: ****\n        region: \"fewspiservice\"\n        version: \"1.25\"\n        filter: \"HKV_WV_1\"\n        parameters: [\"WNSHDB1\"]  \n       \n\nDataAdapter:\n    ...\n\nGlobalVariables:\n\nrootdir: Bestandslocatie van de invoer- en uitvoerbestanden\nmoments: Momenten in uren waar gegevens voor opgehaald moet worden (bijv. -24, 0, +24, +48, +72 uur)\n\n\n\nLoadsFews:\n\nhost: Fews PI REST url\nport: Fews PI REST poortnummer\nregion: FEWS PI REST regionaam\nversion: FEWS PI versienummer\nfilter: Filternaam zoals deze in FEWS wordt gebruikt\nparameters: Parameternaam zoals deze in FEWS wordt gebruikt\n\n\n\nInvoer schema locaties:\n\nmeasurement_location_id (int): Meetlocatie id\nmeasurement_location_code (str): Meetlocatie code\nmeasurement_location_description (str): Meetlocatie omschrijving/naam\n\n\n\nUitvoer schema:\n\nmeasurement_location_id (int): Meetlocatie id\nmeasurement_location_code (str): Meetlocatie code\nmeasurement_location_description (str): Meetlocatie omschrijving/naam\nparameter_id (int): Parameter id overeenkomstig Aquo-standaard\nparameter_code (str): Parameter code overeenkomstig Aquo-standaard\nparameter_description (str): Parameter omschrijving overeenkomstig Aquo-standaard\nunit (str): Eenheid van de waarde\ndate_time (datetime): Datum en tijd van de waarde\nvalue (float): Waarde\nvalue_type (str): Type waarde: meting of verwachting\n\n\n\n\nMatroos\nMatroos of Multifunctional Access Tool for Operational Oceandata Services is een webbased distributiesysteem van de operationele verwachtingen van waterstanden, stroming, debieten en golven, van onder meer het Watermanagementcentrum Nederland. Matroos is beschikbaar voor verschillende doelgroepen, waarvan er op dit moment drie relevant zijn voor de ontwikkeling van de Toolbox Continu Inzicht. De verschillende versies worden in de tabel hieronder toegelicht. Voor meer informatie verwijzen we naar de nieuwsbrief op iplo.nl. In de Toolbox wordt nu alleen de series API gebruikt, dus volstaat NOOS.\n\n\n\nURL\nType\nInhoud\nDoelgroep\n\n\n\n\nvitaal.matroos.rws.nl\nextern, vitaal\n21 dagen\nKustwacht, Waterschappen\n\n\nmatroos.rws.nl\nextern\nVolledige historie\nWaterschappen, universiteiten, externe\n\n\nnoos.matroos.rws.nl\nextern, open\nBeperkte set; series:volledig; maps: 14 dagen\nNOOS internationaal, Open Data\n\n\n\nIn Matroos zijn verschillende bronnen beschikbaar, met get_matroos_sources() kan een lijst van deze worden gegeneerd. De beschikbare locaties kunnen worden weergegeven met get_matroos_locations(), met mogelijkheid om te filteren op een bron en parameter.\n\nGlobalVariables:\n    rootdir: \"data_sets\"\n    moments: [-24,0,24,48]\n    ...\n\n    LoadsMatroos:\n        website: \"noos\" # noos, vitaal of matroos\n        model: \"observed\"\n        parameters: [\"WATHTE\"]\n\nDataAdapter:\n    ...\nVoor het gebruik van vitaal.matroos en matroos is een gebruikersnaam en wachtwoord nodig. Deze moeten in de environmental variables worden meegegeven (.env bestand).\nvitaal_user: \"...\"\nvitaal_password: \"...\"\n# of\nmatroos_user: \"...\"\nmatroos_password: \"...\"\n\n\nRWS WaterWebservices\nVia de RWS WaterWebservices zijn metingen en verwachtingen van o.a. waterstanden beschikbaar via de WaterWebservices API. Vooral langs de rivieren zijn veel meetpunten beschikbaar. Deze API is openbaar en vereist weinig configuratie. De MISSING_VALUE kan in de configuratie worden aangepast, maar staat al standaard ingesteld.\n    LoadsWaterwebservicesRWS:\n        parameters:  [\"WATHTE\"]\nBeschikbare locaties kunnen worden weergegeven met get_rws_webservices_locations().\n\n\nRWS Waterinfo\nNaast de RWS WaterWebservices is alle informatie van Rijkswaterstaat ook verkrijgbaar via waterinfo.rws.nl. Waterinfo is bedoeld als informatieportaal, en niet als API om data op te halen. Voordat de WaterWebservices API beschikbaar was, werd de Waterinfo-website gebruikt in verschillende Continu Inzicht systemen. Om de comptabiliteit met deze oudere Continu Inzicht systemen te behouden, is deze functie nu nog wel beschikbaar in de Toolbox Continu Inzicht. Wel is in de toekomst mogelijk dat door veranderingen aan de Waterinfo-website deze ondersteuning komt te vervallen.\n GlobalVariables:\n    rootdir: \"data_sets\"\n    moments: [-24,48]\n\n    LoadsWaterinfo:\n        parameters: [\"waterhoogte\"]\nOmdat data ophalen uit Waterinfo gevoeliger is, worden de verschillende parameters hieronder weergegeven.\n\nWaterhoogteWindsnelheidGolfhoogteWatertemperatuurLuchttemperatuurAstronomisch getijStroomsnelheidDebietChloride\n\n\n\n\n\n\n\n\n\n\nomschrijving\nmaptype\nperiode\n\n\n\n\nWaterhoogte in cm\nwaterhoogte\n2d terug, 2d vooruit: -48,486u terug, 3u vooruit: -6,39d terug, 2d vooruit: -216,4828d terug: -672,0\n\n\n\n\n\n\n\n\n\n\n\n\n\nomschrijving\nmaptype\nperiode\n\n\n\n\nWindsnelheid in m/s\nwind\n2d terug: -48,486u terug: -6,39d terug: -216,4828d terug: -672,0\n\n\n\n\n\n\n\n\n\n\n\n\n\nomschrijving\nmaptype\nperiode\n\n\n\n\nGolfhoogte in cm\ngolfhoogte\n2d terug, 2d vooruit: -48,486u terug, 3u vooruit: -6,39d terug, 2d vooruit: -216,4828d terug: -672,0\n\n\n\n\n\n\n\n\n\n\n\n\n\nomschrijving\nmaptype\nperiode\n\n\n\n\nWatertemperatuur in °C\nwatertemperatuur\n2d terug: -48,06u terug: -6,09d terug: -216,028d terug:-672,0\n\n\n\n\n\n\n\n\n\n\n\n\n\nomschrijving\nmaptype\nperiode\n\n\n\n\nLuchttemperatuur in °C\nluchttemperatuur\n2d terug: -48,06u terug: -6,09d terug: -216,028d terug:-672,0\n\n\n\n\n\n\n\n\n\n\n\n\n\nomschrijving\nmaptype\nperiode\n\n\n\n\nAstronomisch getij\nastronomische-getij\n2d terug, 2d vooruit: -48,486u terug, 3u vooruit:-6,39d terug, 2d vooruit: -216,4828d terug:-672,0\n\n\n\n\n\n\n\n\n\n\n\n\n\nomschrijving\nmaptype\nperiode\n\n\n\n\nStroomsnelheid in m/s\nstroming\n2d terug: -48,06u terug:-6,09d terug: -216,028d terug:-672,0\n\n\n\n\n\n\n\n\n\n\n\n\n\nomschrijving\nmaptype\nperiode\n\n\n\n\nDebiet in m3/s\nwaterafvoer\n2d terug, 2d vooruit: -48,486u terug, 3u vooruit: -6,39d terug, 2d vooruit:-216,4828d terug:-672,0\n\n\n\n\n\n\n\n\n\n\n\n\n\nomschrijving\nmaptype\nperiode\n\n\n\n\nChloride in mg/l\nzouten\n2d terug: -48,06u terug: -6,09d terug: -216,028d terug:-672,0\n\n\n\n\n\n\n\n\nInvoer schema locaties:\n\nmeasurement_location_id (int): Meetlocatie id\nmeasurement_location_code (str): Meetlocatie code\nmeasurement_location_description (str): Meetlocatie omschrijving/naam\n\n\n\nUitvoer schema:\n\nmeasurement_location_id (int): Meetlocatie id\nmeasurement_location_code (str): Meetlocatie code\nmeasurement_location_description (str): Meetlocatie omschrijving/naam\nparameter_id (int): Parameter id overeenkomstig Aquo-standaard\nparameter_code (str): Parameter code overeenkomstig Aquo-standaard\nparameter_description (str): Parameter omschrijving overeenkomstig Aquo-standaard\nunit (str): Eenheid van de waarde\ndate_time (datetime): Datum en tijd van de waarde\nvalue (float): Waarde\nvalue_type (str): Type waarde: meting of verwachting\n\n\n\n\n\nClassificeren van belastingen\nDe verschillende hierboven benoemde functies voor het inlezen van belastingen geven een tijdreeks terug op bepaalde punten. Deze kunnen omgezet worden naar moment, geclassificeerd met grenswaardes en toegekend aan dijkvakken.\n\nTijdreeks naar momenten\nDe ingelezen tijdsreeks met belastingen wordt omgezet naar belastingen op specifieke momenten met LoadsToMoments.\nVoor gebieden waar het getij van invloed is, is een aanvullende configuratie nodig. Bij getij wordt de maximale belasting tijdens een getijdencyclus (+/-12.25 uur) bepaald. Zonder deze configuratie wordt de belasting exact op het vooraf gedefinieerde moment bepaald.\n\nConfiguratieCode\n\n\nGlobalVariables:\n    rootdir: \"data_sets\"\n    moments: [-24,0,24,48]\n\n    LoadsToMoments:\n        tide: true\n\nDataAdapter:\n    default_options:\n        csv:\n            sep: \",\"\n    waterstanden_waterinfo:\n        type: csv\n        path: \"waterstanden_waterinfo.csv\"\n    waterstanden_waterinfo_maxima:\n        type: csv\n        path: \"waterstanden_waterinfo_maxima.csv\"\n\n\nfrom toolbox_continu_inzicht import Config, DataAdapter\nfrom toolbox_continu_inzicht.loads import LoadsToMoments\n\nconfig = Config(config_path=\"config.yaml\")\nconfig.lees_config()\ndata_adapter = DataAdapter(config=config)\nmoments = LoadsToMoments(data_adapter=data_adapter)\nmoments.run(input=\"waterstanden_waterinfo\", output=\"waterstanden_waterinfo_maxima\")\n\n\n\n\n\nClassificeren van belastingen\nMet LoadsClassify kunnen met vooraf gedefinieerde grenswaardes de belastingen worden geclassificeerd, bijvoorbeeld als waterstand die 1 keer per 100 jaar voorkomt. Hierbij moeten de data-adapters van de grenswaardes en belastingen worden doorgegeven in een lijst. Hierbij is de volgorde van de lijst belangrijk: eerst grenswaardes en dan belastingen. De belastingen moeten voor het classificeren aangeleverd worden als momentwaardes.\n\nConfiguratieCode\n\n\nGlobalVariables:\n    rootdir: \"data_demo\"\n    moments: [-24,0,24,48]\n\n    LoadsMaxima:\n        tide: False\n\nDataAdapter:\n    default_options:\n        csv:\n            sep: \",\"\n    waterstanden_waterinfo_maxima:\n        type: csv\n        path: \"waterstanden_waterinfo_maxima.csv\"\n    waterinfo_klassengrenzen:\n        type: csv\n        path: \"klassengrenzen.csv\"\n    waterstanden_waterinfo_klassen:\n        type: csv\n        path: \"waterstanden_waterinfo_klassen.csv\"\n\n\nfrom toolbox_continu_inzicht import Config, DataAdapter\nfrom toolbox_continu_inzicht.loads import LoadsClassify\n\nconfig = Config(config_path=\"config.yaml\")\nconfig.lees_config()\ndata_adapter = DataAdapter(config=config)\nclassify = LoadsClassify(data_adapter=data_adapter)\nclassify.run(\n    input=[\"waterinfo_klassengrenzen\", \"waterstanden_waterinfo_maxima\"],\n    output=\"waterstanden_waterinfo_klassen\",\n)\n\n\n\n\n\nToekennen van belastingen aan secties\nDe belastingen zijn nu beschikbaar op de meetlocaties van FEWS, Matroos, RWS Waterinfo of RWS WaterWebServices. De volgende stap is het vertalen van de belastingen in de meetpunten naar de secties (dijkvakken of kunstwerken) via SectionsLoads. Voor het toekennen van belastingen aan secties zijn drie databronnen nodig: de dijkvakken, de belastingen en een koppeling tussen dijkvakken en belastinglocaties. De drie data-adapters worden vervolgens doorgegeven als een lijst. Hierbij is de eerder genoemde volgorde van belang: dijkvakken, belastingen en koppeling dijkvakken en belastinglocaties. Als een sectie tussen twee meetpunten ligt, wordt een interpolatiealgoritme (bijv. 25% waarde in meetpunt 1 + 75% waarde in meetpunt 2) toegepast. Omdat dit lokaal kan verschillen hoe deze interpolatie wordt gemaakt, is er geen automatische script voor. De interpolatie moet dus vooraf gedefinieerd worden door de gebruiker en wordt meegegeven bij de koppeling tussen dijkvakken en belastinglocaties. Hierbij wordt gebruik gemaakt van fractionup en fractiondown om het gewicht van de bovenstroomse en benedenstroomse belastinglocatie te bepalen.\n\nConfiguratieCode\n\n\nGlobalVariables:\n    rootdir: \"data_demo\"\n    moments: [-24,0,24,48]\n\n    SectionsLoads:\n        MISSING_VALUE: -9999.0\n\nDataAdapter:\n    default_options:\n        csv:\n            sep: \",\"\n    dijkvakken:\n        type: csv\n        path: \"dijkvakken.csv\"\n    waterstanden:\n        type: csv\n        path: \"waterstanden_waterinfo.csv\"\n    koppeling_dijkvak_belastinglocatie:\n        type: csv\n        path: \"dijkvak_belastinglocatie.csv\"\n    waterstanden_per_dijkvak:\n        type: csv\n        path: \"waterstanden_per_dijkvak.csv\"\n\n\nfrom toolbox_continu_inzicht import Config, DataAdapter\nfrom toolbox_continu_inzicht.sections import SectionsLoads\n\nconfig = Config(config_path=\"config.yaml\")\nconfig.lees_config()\ndata_adapter = DataAdapter(config=config)\nsections_loads = SectionsLoads(data_adapter=data_adapter)\nsections_loads.run(\n    input=[\"dijkvakken\", \"waterstanden\", \"koppeling_dijkvak_belastinglocatie\"],\n    output=\"waterstanden_per_dijkvak\",\n)",
    "crumbs": [
      "Modules",
      "Belastingen inlezen en classificeren"
    ]
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "Installatie-instructies",
    "section": "",
    "text": "De Toolbox Continu Inzicht kan op verschillende manieren worden gebruikt:\n\nAls vervanging van de huidige Continu Inzicht back-end\nAls losstaande modules\nAls ontwikkelaar\n\n\n\nOm de toolbox als vervanging van de huidige Continu Inzicht back-end te gebruiken, zal in de toekomst meer informatie beschikbaar gesteld worden. De oude back-end kan met weinig aanpassingen worden vervangen door de nieuwe code. Verdere aanpassingen die in de toolbox worden gedaan, kunnen dan worden meegenomen.\n\n\n\nOm de toolbox als losstaande modules te gebruiken kan je de code downloaden van PyPi.\npip install toolbox_continu_inzicht\n\n\n\nZie het document CONTRIBUTING.md voor meer informatie.",
    "crumbs": [
      "Installeren",
      "Installatie-instructies"
    ]
  },
  {
    "objectID": "install.html#vervanging",
    "href": "install.html#vervanging",
    "title": "Installatie-instructies",
    "section": "",
    "text": "Om de toolbox als vervanging van de huidige Continu Inzicht back-end te gebruiken, zal in de toekomst meer informatie beschikbaar gesteld worden. De oude back-end kan met weinig aanpassingen worden vervangen door de nieuwe code. Verdere aanpassingen die in de toolbox worden gedaan, kunnen dan worden meegenomen.",
    "crumbs": [
      "Installeren",
      "Installatie-instructies"
    ]
  },
  {
    "objectID": "install.html#losstaande-modules",
    "href": "install.html#losstaande-modules",
    "title": "Installatie-instructies",
    "section": "",
    "text": "Om de toolbox als losstaande modules te gebruiken kan je de code downloaden van PyPi.\npip install toolbox_continu_inzicht",
    "crumbs": [
      "Installeren",
      "Installatie-instructies"
    ]
  },
  {
    "objectID": "install.html#als-ontwikkelaar",
    "href": "install.html#als-ontwikkelaar",
    "title": "Installatie-instructies",
    "section": "",
    "text": "Zie het document CONTRIBUTING.md voor meer informatie.",
    "crumbs": [
      "Installeren",
      "Installatie-instructies"
    ]
  },
  {
    "objectID": "examples/notebooks/3.fragility_curve_overtopping.html",
    "href": "examples/notebooks/3.fragility_curve_overtopping.html",
    "title": "Fragility Curve Overtopping",
    "section": "",
    "text": "Voor het berekenen van een fragility curve voor het mechanisme GEKB wordt gebruikt gemaakt van de pydra_core module, meer documentatie over de pydra_core module is hier te vinden.\nDe module wordt gebruikt om een overslag debiet te berekenen voor verschillende omstandigheden en op basis hiervan wordt een fragility curve opgesteld.\n\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\n\nfrom toolbox_continu_inzicht.fragility_curves import (\n    ChangeCrestHeightFragilityCurveOvertopping,\n    FragilityCurveOvertopping,\n    ShiftFragilityCurveOvertopping,\n)\n\n\nfrom toolbox_continu_inzicht.base.data_adapter import Config, DataAdapter\n\npath = Path.cwd() / \"data_sets\"\nconfig = Config(config_path=path / \"test_fragility_curve_overtopping.yaml\")\nconfig.lees_config()\ndata_adapter = DataAdapter(config=config)\n\nDe volgende configuratie wordt gebruikt voor het maken van een GEKB curve\nGlobalVariables:\n    rootdir: \"data_sets\"\n    moments: [-24,0,24,48]\n\n    FragilityCurveOvertopping:\n        gh_onz_mu: 0.96 # default waardes, kunnen worden overschreven\n        gh_onz_sigma: 0.27\n        gp_onz_mu_tp: 1.03\n        gp_onz_sigma_tp: 0.13\n        gp_onz_mu_tspec: 1.03\n        gp_onz_sigma_tspec: 0.13\n        gh_onz_aantal: 7\n        gp_onz_aantal: 7\n        tp_tspec: 1.1\n        lower_limit_coarse: 4.0\n        upper_limit_coarse: 2.0\n        upper_limit_fine: 1.0\n        hstap: 0.05\n\nDataAdapter:\n    default_options:\n        csv:\n            sep: \",\"\n    slopes:\n        type: csv\n        file: \"slopes_5.csv\"\n    profiles:\n        type: csv\n        file: \"profiles_new.csv\"\n    bedlevel_fetch:\n        type: csv\n        file: \"bedlevelfetch_11.csv\"\n    fragility_curves:\n        type: csv\n        file: \"fragility_curves_5.csv\"\nEr zijn drie verschillende data bestanden nodig. Ten eerst een table met de informatie over de helling (slope) waarvoor de curve wordt afgeleid\n\ndata_adapter.input(\"slopes\")\n\n\n\n\n\n\n\n\nprofileid\nslopetypeid\nx\ny\nr\ndamheight\n\n\n\n\n0\n5\n1\n-12.59\n10.76\n1\n0\n\n\n1\n5\n1\n0.00\n14.63\n1\n0\n\n\n2\n5\n2\n-68.82\n10.00\n1\n0\n\n\n3\n5\n2\n-12.59\n10.76\n1\n0\n\n\n\n\n\n\n\nTen tweede informatie over de hoogte van de kruin, de oriëntatie, of er een dam is, maatgevende windsnelheid enz.\n\ndata_adapter.input(\"profiles\")\n\n\n\n\n\n\n\n\nparameters\nvalues\n\n\n\n\n0\nsectionid\n11\n\n\n1\ncrestlevel\n14.63\n\n\n2\norientation\n167\n\n\n3\ndam\n0\n\n\n4\ndamheight\n0\n\n\n5\nqcr\nclosed\n\n\n6\nwindspeed\n20\n\n\n7\nsectormin\n180.0\n\n\n8\nsectorsize\n90.0\n\n\n9\nclosing_situation\n0\n\n\n\n\n\n\n\nTen derde informatie over het bodemprofiel:\n\ndata_adapter.input(\"bedlevel_fetch\").head(4)  # (ingekorte versie)\n\n\n\n\n\n\n\n\nsectionid\ndirection\nbedlevel\nfetch\n\n\n\n\n0\n11\n22.5\n10.39860\n83.2947\n\n\n1\n11\n45.0\n10.06460\n411.6820\n\n\n2\n11\n67.5\n9.52596\n797.4780\n\n\n3\n11\n90.0\n9.18148\n1078.2800\n\n\n\n\n\n\n\nDeze informatie wordt mee gegeven aan de FragilityCurveOvertopping voor het genereren van een curve\n\nfragility_curve_overtopping = FragilityCurveOvertopping(data_adapter=data_adapter)\nfragility_curve_overtopping.run(\n    input=[\"slopes\", \"profiles\", \"bedlevel_fetch\"],\n    output=\"fragility_curves\",\n)\n\nDeze curve kunnen we vervolgens weergeven:\n\nfig, ax = plt.subplots()\nfragility_curve_overtopping.df_out.set_index(\"waterlevels\").plot(ax=ax)\nax.set_ylabel(\"Failure probability\");\n\n\n\n\n\n\n\n\nIn sommige gevallen wil je een fragility curve ook aan kunnen passen, om dit mogelijk te maken zijn verschillende functie beschikbaar die het zelfde doen als de originele functie maar een kleine, door de gebruiker opgelegde, aanpassingen doen.  Zo verschuift de functie ShiftFragilityCurveOvertopping de fragility curve met een effect.\n\nshift_fragility_curve_overtopping = ShiftFragilityCurveOvertopping(\n    data_adapter=data_adapter\n)\n\nshift_fragility_curve_overtopping.run(\n    input=[\"slopes\", \"profiles\", \"bedlevel_fetch\"],\n    output=\"fragility_curves\",\n    effect=0.5,\n)\n\n\nfig, ax = plt.subplots(1, 1)\n\n# pas de namen van de kolommen aan voor de plot\ndf_overtopping = fragility_curve_overtopping.df_out.set_index(\"waterlevels\").rename(\n    columns={\"failure_probability\": \"original\"}\n)\ndf_overtopping_shift = shift_fragility_curve_overtopping.df_out.set_index(\n    \"waterlevels\"\n).rename(columns={\"failure_probability\": \"shifted\"})\n\n# plotten\ndf_overtopping.plot(ax=ax)\ndf_overtopping_shift.plot(ax=ax, linestyle=\"--\", label=\"shifted\")\nax.set_ylabel(\"Failure probability\");\n\n\n\n\n\n\n\n\nWaar verschuiven een relatief simple nabewerking op de data is, kunnen aanpassingen aan de berekening zelf ‘on-the-fly’ plaatsvinden.  Zo kan als maatregel de kruinhoogte worden verhoogt, met de functie ChangeCrestHeightFragilityCurveOvertopping is dit mogelijk.\n\nchange_crest_fragility_curve_overtopping = ChangeCrestHeightFragilityCurveOvertopping(\n    data_adapter=data_adapter\n)\n\nchange_crest_fragility_curve_overtopping.run(\n    input=[\"slopes\", \"profiles\", \"bedlevel_fetch\"],\n    output=\"fragility_curves\",\n    effect=0.5,\n)\n\n\nfig, ax = plt.subplots(1, 1)\n\n# pas de namen van de kolom aan voor de plot\ndf_overtopping_change_crest = change_crest_fragility_curve_overtopping.df_out.set_index(\n    \"waterlevels\"\n).rename(columns={\"failure_probability\": \"change crest\"})\n\n# plotten\ndf_overtopping.plot(ax=ax)\ndf_overtopping_change_crest.plot(ax=ax, linestyle=\"--\")\nax.set_ylabel(\"Failure probability\");",
    "crumbs": [
      "Fragility Curve Overtopping"
    ]
  },
  {
    "objectID": "examples/notebooks/1.proof_of_concept.html",
    "href": "examples/notebooks/1.proof_of_concept.html",
    "title": "Voorbeelden",
    "section": "",
    "text": "Hieronder wordt één voorbeeld gegeven van hoe de architectuur werkt. In de linker balk zijn nog een aantal voorbeelden te vinden.  Er zullen later nog meer voorbeelden aan toegevoegd worden.  Meer voorbeelden met de juiste data en configuratie bestanden zijn te vinden op github onder toolbox-continu-inzicht/tests/.",
    "crumbs": [
      "Voorbeelden"
    ]
  },
  {
    "objectID": "examples/notebooks/1.proof_of_concept.html#voorbeeld-met-csv",
    "href": "examples/notebooks/1.proof_of_concept.html#voorbeeld-met-csv",
    "title": "Voorbeelden",
    "section": "Voorbeeld met CSV",
    "text": "Voorbeeld met CSV\nLees de configuratie in:\nDit leest een configuratie bestand test_config.yaml in:\nGlobalVariables:\n    rootdir: \"data_sets\"\n\nDataAdapter:\n    default_options:\n        postgresql_database:\n            database: \"citoolbox\"\n            schema: \"citoolbox_schema\"\n    \n    my_csv_in: \n        type: csv\n        file: \"test_csv_in.csv\"\n    my_csv_out: \n        type: csv\n        file: \"test_csv_out.csv\"\n    my_postgresql: \n        type: postgresql_database\n        table: data\n\n...\n\nc = Config(config_path=\"data_sets/test_config.yaml\")\nc.lees_config()\n\nZet de data adapter klaar en geef deze de configuratie mee\n\nfrom toolbox_continu_inzicht import DataAdapter\n\ndata = DataAdapter(config=c)\n\nRun de module met CSV\n\nfrom toolbox_continu_inzicht.proof_of_concept import ValuesTimesTwo\n\nkeer_twee = ValuesTimesTwo(data_adapter=data)\n\n\nkeer_twee.run(input=\"my_csv_in\", output=\"my_csv_out\")\n\n\nkeer_twee.df_in\n\n\n\n\n\n\n\n\nobjectid\nobjecttype\nparameterid\ndate_time\nvalue\n\n\n\n\n0\n1\nmeasuringstation\n1\n1726227377000\n4.8\n\n\n1\n2\nmeasuringstation\n1\n1726227377000\n5.0\n\n\n2\n3\nmeasuringstation\n1\n1726227377000\n5.2\n\n\n3\n4\nmeasuringstation\n1\n1726227377000\n5.4\n\n\n4\n5\nmeasuringstation\n1\n1726227377000\n5.6\n\n\n\n\n\n\n\n\nkeer_twee.df_out\n\n\n\n\n\n\n\n\nobjectid\nobjecttype\nparameterid\ndate_time\nvalue\n\n\n\n\n0\n1\nmeasuringstation\n1\n1726227377000\n9.6\n\n\n1\n2\nmeasuringstation\n1\n1726227377000\n10.0\n\n\n2\n3\nmeasuringstation\n1\n1726227377000\n10.4\n\n\n3\n4\nmeasuringstation\n1\n1726227377000\n10.8\n\n\n4\n5\nmeasuringstation\n1\n1726227377000\n11.2\n\n\n\n\n\n\n\nde values waardes uit de vorige table zijn vermenigvuldigd met twee\nZelf proberen? Dit voorbeeld is te vinden op Github",
    "crumbs": [
      "Voorbeelden"
    ]
  },
  {
    "objectID": "contact.html",
    "href": "contact.html",
    "title": "Contact",
    "section": "",
    "text": "Voor meer informatie, vragen of opmerkingen over de Toolbox Continu Inzicht kunt u terecht bij:\nSTOWA: Oscar van Dam (vandam@stowa.nl) HKV: Marit Zethof (m.zethof@hkv.nl) en Bart Thonus (b.thonus@hkv.nl)",
    "crumbs": [
      "Overig",
      "Contact"
    ]
  },
  {
    "objectID": "changelog.html",
    "href": "changelog.html",
    "title": "Changelog",
    "section": "",
    "text": "Alle noemenswaardige veranderingen worden hier bijgehouden. Dit project gebruikt Semantic Versioning. Het format is beschreven op keepachangelog.com.\n\n\n\n\n\nWerkende Quarto documentatie #7\nProof of concept met csv en database #9\nVoeg notebook toe om te laten zien hoe het werkt #12\nMaak map structuur overzichtelijker #19\n\n\n\n\nIn sprint 2 is gebruikt gemaakt van aparte ‘feature branches’ met een grote pull request naar main #36.\nAllereerst zijn er nog restpunten uit sprint 1 aangepast:\n\nhet specificeren van delimiter deed het niet, dit moet sep zijn. Daarnaast worden nu alle opties die in de configuratie zijn gespecificeerd doorgegeven aan de data adapters.\npath is nu file, waarbij file altijd een bestand is in de rootdir. ‘path’ mag ook een ander absoluut pad zijn: bijvoorbeeld een bestand op een andere locatie. Er wordt ook gecheckt of de paden bestaan voor het runnen van een functie.\n.env bestand is niet meer verplicht, maar geeft wel een warning\nutil map aangemaakt voor generieke functies als tijd en post/get functies\npytest.skipif voor testen die alleen op het HKV-netwerk draaien door FEWS/postgreSQL verbindingen.\nde keywords input=.. en output=.. worden nu alleen aan de .run() functie doorgegeven, niet aan de class zelf.\n\nDaarnaast zijn er toevoegingen gedaan ten behoeve van het inlezen van belastingen:\n\nInlezen en ophalen van locaties, parameters en grenswaardes(waar mogelijk) uit:\n\n(Noos/Vitaal) Matroos\nFEWS\nRWS waterinfo\nRWS waterwebservices\n\n\nDeze inleesfuncties gebruiken allemaal de Aquo-standaard naam en code (WATHTE).\n\nClassificeren van belastingen aan de hand van opgehaalde/opgegeven grenswaardes.\nToekennen van belastingen aan secties.\nAggregeren van tijdreeksen naar momenten of bij het getij naar maxima over de getijperiode.\n\n\n\n\n\n\n\nIn sprint 3 is weer gebruikt gemaakt van aparte ‘feature branches’ met een grote pull request naar main #45.\nDe nadruk lag vooral op het toevoegen van fragility curves. Fragility curves kunnen worden gemaakt voor GEKB (golfoverslag) en STPH (piping). Ook kunnen ze afhankelijk, onafhankelijk en met een gewogen gemiddelde worden gecombineerd. Hiervoor zijn de packages respectievelijk pydra_core en probabilistic piping gebruikt.\nDaarnaast zijn er een heel aantal data adapters toegevoegd en veel voorbeelden hoe je het kan linken aan een continu inzicht database, daar data op kan zetten en vervolgens gebruiken in functies.\n\n\n\nDe pre-commit uitgebreid en toegevoegd aan de github actions, dit run je voor je een aanpassingen doorvoer met pixi run pre-commit. De tests en publiceren van docs is nu in een windows action omgeving zodat de Dll’s van pydra_core het doen, de pixi.lock is geupdate om nieuwe packages toe te laten.",
    "crumbs": [
      "Overig",
      "Changelog"
    ]
  },
  {
    "objectID": "changelog.html#ongeplubliceerd",
    "href": "changelog.html#ongeplubliceerd",
    "title": "Changelog",
    "section": "",
    "text": "Werkende Quarto documentatie #7\nProof of concept met csv en database #9\nVoeg notebook toe om te laten zien hoe het werkt #12\nMaak map structuur overzichtelijker #19\n\n\n\n\nIn sprint 2 is gebruikt gemaakt van aparte ‘feature branches’ met een grote pull request naar main #36.\nAllereerst zijn er nog restpunten uit sprint 1 aangepast:\n\nhet specificeren van delimiter deed het niet, dit moet sep zijn. Daarnaast worden nu alle opties die in de configuratie zijn gespecificeerd doorgegeven aan de data adapters.\npath is nu file, waarbij file altijd een bestand is in de rootdir. ‘path’ mag ook een ander absoluut pad zijn: bijvoorbeeld een bestand op een andere locatie. Er wordt ook gecheckt of de paden bestaan voor het runnen van een functie.\n.env bestand is niet meer verplicht, maar geeft wel een warning\nutil map aangemaakt voor generieke functies als tijd en post/get functies\npytest.skipif voor testen die alleen op het HKV-netwerk draaien door FEWS/postgreSQL verbindingen.\nde keywords input=.. en output=.. worden nu alleen aan de .run() functie doorgegeven, niet aan de class zelf.\n\nDaarnaast zijn er toevoegingen gedaan ten behoeve van het inlezen van belastingen:\n\nInlezen en ophalen van locaties, parameters en grenswaardes(waar mogelijk) uit:\n\n(Noos/Vitaal) Matroos\nFEWS\nRWS waterinfo\nRWS waterwebservices\n\n\nDeze inleesfuncties gebruiken allemaal de Aquo-standaard naam en code (WATHTE).\n\nClassificeren van belastingen aan de hand van opgehaalde/opgegeven grenswaardes.\nToekennen van belastingen aan secties.\nAggregeren van tijdreeksen naar momenten of bij het getij naar maxima over de getijperiode.\n\n\n\n\n\n\n\nIn sprint 3 is weer gebruikt gemaakt van aparte ‘feature branches’ met een grote pull request naar main #45.\nDe nadruk lag vooral op het toevoegen van fragility curves. Fragility curves kunnen worden gemaakt voor GEKB (golfoverslag) en STPH (piping). Ook kunnen ze afhankelijk, onafhankelijk en met een gewogen gemiddelde worden gecombineerd. Hiervoor zijn de packages respectievelijk pydra_core en probabilistic piping gebruikt.\nDaarnaast zijn er een heel aantal data adapters toegevoegd en veel voorbeelden hoe je het kan linken aan een continu inzicht database, daar data op kan zetten en vervolgens gebruiken in functies.\n\n\n\nDe pre-commit uitgebreid en toegevoegd aan de github actions, dit run je voor je een aanpassingen doorvoer met pixi run pre-commit. De tests en publiceren van docs is nu in een windows action omgeving zodat de Dll’s van pydra_core het doen, de pixi.lock is geupdate om nieuwe packages toe te laten.",
    "crumbs": [
      "Overig",
      "Changelog"
    ]
  },
  {
    "objectID": "contributing.html",
    "href": "contributing.html",
    "title": "Richtlijnen voor bijdragen aan Toolbox Continu Inzicht",
    "section": "",
    "text": "Het ontwikkelen van de Toolbox Continu Inzicht bestaat uit twee delen. Eerst ontwikkelt HKV de basisfunctionaliteit. Deze ontwikkeling is voor iedereen te volgen op GitHub, maar toevoegingen worden nog niet geaccepteerd. Daarna blijft het project open source beschikbaar en kan het verder worden ontwikkeld. De term ‘ontwikkelaars’ duidt in de eerste ontwikkelfase op het team van HKV, later op anderen die een bijdrage willen leveren. Een bijdrage kan uiteenlopen van een vraag tot een grote wijziging via een pull request.\nEen bijdrage kan een van de volgend zaken zijn:\n\nJe hebt een vraag\nJe denkt een probleem (bug) te hebben gevonden (of onverwachte functionaliteit)\nJe wilt een aanpassing maken (bug fixen, nieuwe functionaliteit, update aan de documentatie)\nJe wilt een nieuwe versie publiceren\n\nDe onderstaande secties behandelen de stappen per geval.\n\n\n\nGebruik de zoekfunctie hier om te kijken of iemand anders dezelfde vraag heeft.\nAls je niks vergelijkbaars kan vinden, maak een nieuwe issue aan.\nVoeg het \"Question” label toe; voeg andere labels toe waar nodig.\n\n\n\n\n\nGebruik de zoekfunctie hier om te kijken of iemand anders dezelfde vraag/probleem heeft.\nAls je niks vergelijkbaars kan vinden, maak een nieuwe issue aan. Zorg dat je genoeg informatie meegeeft zodat andere ontwikkelaars je probleem begrijpen en genoeg context hebben om je te helpen. Afhankelijk van je probleem, kan je de SHA hashcode van de commit die problemen veroorzaakt toevoegen. Denk daarnaast ook aan versie- en besturingssysteeminformatie.\nVoeg labels toe die relevant zijn voor je probleem.\n\n\n\n\n\n(Belangrijk) Communiceer aan de rest van de ontwikkelaars voor je begint dat je een aanpassing wilt maken. Dit laat je weten door een issue aan te maken.\n(Belangrijk) Bereik consensus over je idee.\nDe hoofdontwikkelaars hebben rechten om nieuwe branches aan te maken. Als je deze rechten niet hebt, maak een 'fork' (kopie) in je eigen account. In deze fork maak je een eigen branch van de laatste commit in main. Probeer om veranderingen die in de tussentijd worden doorgevoerd op main al mee te nemen. Dit doe je door te pullen van de 'upstream' repository, (zie instructies hier en hier);\nVoor Visual Studio Code staat er een voorbeeldconfiguratie.\nInstalleer de benodigde python packages in een pixi omgeving met pixi install, volg de uitleg van de pixi. Pixi zorgt er voor dat iedereen dezelfde versies van python packages heeft.\nZorg dat de format van je code correct is met pixi run pre-commit. Door het installeren van pre-commit met de volgende commando: pre-commit install --hook-type pre-commit --hook-type pre-push runt deze lokaal automatisch met git commit actie.\nZorg dat alle bestaande testen werken met pixi run pytest. Met pixi run pytest-cov wordt (lokaal) een html overzicht gegenereerd in de map tests/hidden_test_cov/index.html.\nZorg dat alle documentatie automatisch genereert met pixi run quarto-render. Quarto is al onderdeel van de zojuist aangemaakte pixi omgeving.\nVoeg bij nieuwe functionaliteit altijd nieuwe tests toe.\nUpdate en voeg documentatie toe. Gebruik Numpy Style Python docstrings. Zorg dat je code leesbaar en begrijpelijk is voor anderen.\nPush je branch. naar (jouw fork van) de toolbox continu inzicht repo op GitHub;\nMaak een pull request aan, bijvoorbeeld volgens deze instructies. Pull requests die worden ontvangen, krijgen altijd een review.\n\nAls je het idee heb dat je iets nuttig heb toegevoegd, maar je weet niet hoe je tests schrijft of runt of hoe je documentatie aanmaakt: geen probleem. Maak een pull request en dan kijken we hoe we kunnen helpen.\n\n\n\nDit is een stukje voor de hoofdontwikkelaars van toolbox continu inzicht.\n\nCheckout HEAD van de main branch met git checkout main en git pull.\nBeslis welke nieuwe versie (major, minor or patch) gebruikt gaat worden. We gebruiken semantic versioning.\nOmdat je niet direct naar de main branch kan schrijven (protected), maak een nieuwe branch aan met git checkout -b release-&lt;version&gt;.\nIndien dependencies zijn aangepast, maak een nieuw pixi lock bestand.\nPas de versie aan in src/toolbox_continu_inzicht/__init__.py, de pyptoject.toml leest deze uit.\nPas de docs/changelog.qmd aan met de veranderingen. Vergeet de link naar de pull request niet.\nZorg dat de format van je code correct is met pixi run ruff check.\nZorg dat alle bestaande testen werken met pixi run pytest.\nCommit & push je aanpassingen naar GitHub.\nMaak een pull request aan, laat iemand het reviewen, wacht op alle acties, deze worden groen, en merge de pull request.\nWacht tot de GitHub-acties op de main branch klaar zijn en er een groen vinkje bij staat.\nMaak een nieuwe 'release' aan op GitHub\n\nGebruik de versie als titel en pas een versietag toe.\nAls beschrijving gebruik de intro van de README.md en veranderingen uit de changelog.qmd.\n\nCheck\n\nIs de wiki bijgewerkt?\nHeeft de GitHub actie alles naar PyPI gestuurd?\nWerkt de nieuwe versie met: pip3 install toolbox_continu_inzicht==&lt;new version&gt;?\n\nVier je nieuwe versie!",
    "crumbs": [
      "Bijdragen",
      "Richtlijnen voor bijdragen aan Toolbox Continu Inzicht"
    ]
  },
  {
    "objectID": "contributing.html#je-hebt-een-vraag",
    "href": "contributing.html#je-hebt-een-vraag",
    "title": "Richtlijnen voor bijdragen aan Toolbox Continu Inzicht",
    "section": "",
    "text": "Gebruik de zoekfunctie hier om te kijken of iemand anders dezelfde vraag heeft.\nAls je niks vergelijkbaars kan vinden, maak een nieuwe issue aan.\nVoeg het \"Question” label toe; voeg andere labels toe waar nodig.",
    "crumbs": [
      "Bijdragen",
      "Richtlijnen voor bijdragen aan Toolbox Continu Inzicht"
    ]
  },
  {
    "objectID": "contributing.html#je-denkt-een-probleem-bug-te-hebben-gevonden",
    "href": "contributing.html#je-denkt-een-probleem-bug-te-hebben-gevonden",
    "title": "Richtlijnen voor bijdragen aan Toolbox Continu Inzicht",
    "section": "",
    "text": "Gebruik de zoekfunctie hier om te kijken of iemand anders dezelfde vraag/probleem heeft.\nAls je niks vergelijkbaars kan vinden, maak een nieuwe issue aan. Zorg dat je genoeg informatie meegeeft zodat andere ontwikkelaars je probleem begrijpen en genoeg context hebben om je te helpen. Afhankelijk van je probleem, kan je de SHA hashcode van de commit die problemen veroorzaakt toevoegen. Denk daarnaast ook aan versie- en besturingssysteeminformatie.\nVoeg labels toe die relevant zijn voor je probleem.",
    "crumbs": [
      "Bijdragen",
      "Richtlijnen voor bijdragen aan Toolbox Continu Inzicht"
    ]
  },
  {
    "objectID": "contributing.html#je-wilt-een-aanpassing-maken",
    "href": "contributing.html#je-wilt-een-aanpassing-maken",
    "title": "Richtlijnen voor bijdragen aan Toolbox Continu Inzicht",
    "section": "",
    "text": "(Belangrijk) Communiceer aan de rest van de ontwikkelaars voor je begint dat je een aanpassing wilt maken. Dit laat je weten door een issue aan te maken.\n(Belangrijk) Bereik consensus over je idee.\nDe hoofdontwikkelaars hebben rechten om nieuwe branches aan te maken. Als je deze rechten niet hebt, maak een 'fork' (kopie) in je eigen account. In deze fork maak je een eigen branch van de laatste commit in main. Probeer om veranderingen die in de tussentijd worden doorgevoerd op main al mee te nemen. Dit doe je door te pullen van de 'upstream' repository, (zie instructies hier en hier);\nVoor Visual Studio Code staat er een voorbeeldconfiguratie.\nInstalleer de benodigde python packages in een pixi omgeving met pixi install, volg de uitleg van de pixi. Pixi zorgt er voor dat iedereen dezelfde versies van python packages heeft.\nZorg dat de format van je code correct is met pixi run pre-commit. Door het installeren van pre-commit met de volgende commando: pre-commit install --hook-type pre-commit --hook-type pre-push runt deze lokaal automatisch met git commit actie.\nZorg dat alle bestaande testen werken met pixi run pytest. Met pixi run pytest-cov wordt (lokaal) een html overzicht gegenereerd in de map tests/hidden_test_cov/index.html.\nZorg dat alle documentatie automatisch genereert met pixi run quarto-render. Quarto is al onderdeel van de zojuist aangemaakte pixi omgeving.\nVoeg bij nieuwe functionaliteit altijd nieuwe tests toe.\nUpdate en voeg documentatie toe. Gebruik Numpy Style Python docstrings. Zorg dat je code leesbaar en begrijpelijk is voor anderen.\nPush je branch. naar (jouw fork van) de toolbox continu inzicht repo op GitHub;\nMaak een pull request aan, bijvoorbeeld volgens deze instructies. Pull requests die worden ontvangen, krijgen altijd een review.\n\nAls je het idee heb dat je iets nuttig heb toegevoegd, maar je weet niet hoe je tests schrijft of runt of hoe je documentatie aanmaakt: geen probleem. Maak een pull request en dan kijken we hoe we kunnen helpen.",
    "crumbs": [
      "Bijdragen",
      "Richtlijnen voor bijdragen aan Toolbox Continu Inzicht"
    ]
  },
  {
    "objectID": "contributing.html#je-wilt-een-nieuwe-versie-publiceren",
    "href": "contributing.html#je-wilt-een-nieuwe-versie-publiceren",
    "title": "Richtlijnen voor bijdragen aan Toolbox Continu Inzicht",
    "section": "",
    "text": "Dit is een stukje voor de hoofdontwikkelaars van toolbox continu inzicht.\n\nCheckout HEAD van de main branch met git checkout main en git pull.\nBeslis welke nieuwe versie (major, minor or patch) gebruikt gaat worden. We gebruiken semantic versioning.\nOmdat je niet direct naar de main branch kan schrijven (protected), maak een nieuwe branch aan met git checkout -b release-&lt;version&gt;.\nIndien dependencies zijn aangepast, maak een nieuw pixi lock bestand.\nPas de versie aan in src/toolbox_continu_inzicht/__init__.py, de pyptoject.toml leest deze uit.\nPas de docs/changelog.qmd aan met de veranderingen. Vergeet de link naar de pull request niet.\nZorg dat de format van je code correct is met pixi run ruff check.\nZorg dat alle bestaande testen werken met pixi run pytest.\nCommit & push je aanpassingen naar GitHub.\nMaak een pull request aan, laat iemand het reviewen, wacht op alle acties, deze worden groen, en merge de pull request.\nWacht tot de GitHub-acties op de main branch klaar zijn en er een groen vinkje bij staat.\nMaak een nieuwe 'release' aan op GitHub\n\nGebruik de versie als titel en pas een versietag toe.\nAls beschrijving gebruik de intro van de README.md en veranderingen uit de changelog.qmd.\n\nCheck\n\nIs de wiki bijgewerkt?\nHeeft de GitHub actie alles naar PyPI gestuurd?\nWerkt de nieuwe versie met: pip3 install toolbox_continu_inzicht==&lt;new version&gt;?\n\nVier je nieuwe versie!",
    "crumbs": [
      "Bijdragen",
      "Richtlijnen voor bijdragen aan Toolbox Continu Inzicht"
    ]
  },
  {
    "objectID": "examples/notebooks/2.belastingen_inladen.html",
    "href": "examples/notebooks/2.belastingen_inladen.html",
    "title": "Belastingen inladen",
    "section": "",
    "text": "Inlezen waterstanden uit verschillende bronsystemen: - RWS Waterinfo - FEWS - (Noos) Matroos - RWS WaterWebServices\nGebruikmakend van: - csv bestanden voor uitwisselen van data\n\nBenodigde generieke Python packages\n\nfrom pathlib import Path\n\n\n\nDefinitie configuratie: CSV bestanden\nGlobalVariables: rootdir: “data_demo” moments: [-24,0,24,48]\nLoadsWaterinfo:\n    parameters: [\"waterhoogte\"]\n    MISSING_VALUE: 999\n\nLoadsFews:\n    host: \"https://fews.hhnk.nl\"\n    port: 443\n    region: \"fewspiservice\"\n    version: \"1.25\"\n    filter: \"HHNK_WEB\"\n    parameters: [\"WATHTE [m][NAP][OW]\", \"WINDRTG [deg]\"]\n    aquo_equivalent: [\"WATHTE\",\"WINDRTG\"]\n    MISSING_VALUE: 999\n\nLoadsMatroos:\n    website: \"vitaal\"\n    model: \"dcsm6_kf\"\n    parameters: [\"WATHTE\"]\n    MISSING_VALUE: 999\n\nLoadsWaterwebservicesRWS:\n    parameters: [\"WATHTE\"]\n    MISSING_VALUE: 999\nDataAdapter: default_options: csv_source: sep: “;” csv: sep: “,” BelastingLocaties_WaterInfo: type: csv_source filter: “WaterInfo” path: “locaties.csv” Waterstanden_WaterInfo: type: csv path: “waterstanden_waterinfo.csv” BelastingLocaties_FEWS: type: csv_source filter: “FEWS” path: “locaties.csv” Waterstanden_FEWS: type: csv path: “waterstanden_fews.csv” BelastingLocaties_Matroos: type: csv_source filter: “NOOS Matroos” path: “locaties.csv” Waterstanden_Matroos: type: csv path: “waterstanden_matroos.csv” BelastingLocaties_Waterwebservices_RWS: type: csv_source filter: “RWS Waterwebservices” path: “locaties.csv” Waterstanden_Waterwebservices_RWS: type: csv path: “waterstanden_waterwebservices_rws.csv”\n\n\nLees configuratie in en maak dictionary base.Config aan\n\nfrom toolbox_continu_inzicht import Config\n\nyaml_config_file = \"demo_sprint2-I.yaml\"\npath = Path.cwd() / \"data_demo\" / yaml_config_file\nc = Config(config_path=path)\nc.lees_config()\n\n\n\nGeef config mee aan base.Adapter\n\nfrom toolbox_continu_inzicht import DataAdapter\n\ndata = DataAdapter(config=c)\nprint(f\"Folder met data: {data.config.config_path}\")\nprint(f\"Globale variabelen: {data.config.global_variables}\")\nfor data_adapter in data.config.data_adapters:\n    print(f\"Data apdater: {data_adapter}\")\n\nFolder met data: D:\\a\\toolbox-continu-inzicht\\toolbox-continu-inzicht\\continu_inzicht\\docs\\examples\\notebooks\\data_demo\\demo_sprint2-I.yaml\nGlobale variabelen: {'rootdir': 'data_demo', 'moments': [-24, 0, 24, 48], 'LoadsWaterinfo': {'parameters': ['waterhoogte'], 'MISSING_VALUE': 999}, 'LoadsFews': {'host': 'https://fews.hhnk.nl', 'port': 443, 'region': 'fewspiservice', 'version': '1.25', 'filter': 'HHNK_WEB', 'parameters': ['WATHTE [m][NAP][OW]'], 'MISSING_VALUE': 999}, 'LoadsMatroos': {'website': 'noos', 'model': 'dcsm6_kf', 'parameters': ['WATHTE'], 'MISSING_VALUE': 999}, 'LoadsWaterwebservicesRWS': {'parameters': ['WATHTE'], 'MISSING_VALUE': 999}, 'calc_time': datetime.datetime(2025, 1, 30, 12, 0, tzinfo=datetime.timezone.utc)}\nData apdater: default_options\nData apdater: BelastingLocaties_WaterInfo\nData apdater: Waterstanden_WaterInfo\nData apdater: BelastingLocaties_FEWS\nData apdater: Waterstanden_FEWS\nData apdater: BelastingLocaties_Matroos\nData apdater: Waterstanden_Matroos\nData apdater: BelastingLocaties_Waterwebservices_RWS\nData apdater: Waterstanden_Waterwebservices_RWS\n\n\n\n\nInvoerbestand (CSV) met data van belastinglocaties\nVerplichte velden (schema): - measurement_location_id: int64 - measurement_location_code: object (string) - measurement_location_description: object (string)\nmeasurement_location_id;measurement_location_code;measurement_location_description;source;tide\n1;Pannerdense-kop(PANN);Pannerdense kop;WaterInfo;false\n2;MPN-N-24;Meetpunt Spijkerboor;FEWS;false\n3;hoekvanholland;Hoek van Holland;NOOS Matroos;true\n4;9889;Hintham beneden;RWS Waterwebservices;false\n\n\nLaad module (functie) LoadsWaterinfo voor inlezen belastingen uit RWS Waterinfo\n\nfrom toolbox_continu_inzicht.loads import LoadsWaterinfo\n\nwaterinfo = LoadsWaterinfo(data_adapter=data)\n\n\n\nRun module (functie) LoadsWaterinfo voor inlezen waterstanden uit Waterinfo\nLET OP: zoek op basis van een measurement_location_code die in RWS WaterInfo overeenkomt met ‘locationCodes’\n\nds = waterinfo.run(input=\"BelastingLocaties_WaterInfo\", output=\"Waterstanden_WaterInfo\")\n\n\nmeasuringlocations = waterinfo.df_in\nmeasuringlocations\n\n\n\n\n\n\n\n\nmeasurement_location_id\nmeasurement_location_code\nmeasurement_location_description\nsource\ntide\n\n\n\n\n0\n1\nPannerdense-kop(PANN)\nPannerdense kop\nWaterInfo\nFalse\n\n\n\n\n\n\n\n\nwaterlevels = waterinfo.df_out\nwaterlevels\n\n\n\n\n\n\n\n\nmeasurement_location_id\nmeasurement_location_code\nmeasurement_location_description\nparameter_id\nparameter_code\nparameter_description\nunit\ndate_time\nvalue\nvalue_type\n\n\n\n\n146\n1\nPannerdense-kop(PANN)\nPannerdense kop\n4724\nWATHTE\nWaterhoogte Oppervlaktewater t.o.v. Normaal Am...\ncm\n2025-01-29 12:00:00+00:00\n1039.0\nmeting\n\n\n147\n1\nPannerdense-kop(PANN)\nPannerdense kop\n4724\nWATHTE\nWaterhoogte Oppervlaktewater t.o.v. Normaal Am...\ncm\n2025-01-29 12:10:00+00:00\n1039.0\nmeting\n\n\n148\n1\nPannerdense-kop(PANN)\nPannerdense kop\n4724\nWATHTE\nWaterhoogte Oppervlaktewater t.o.v. Normaal Am...\ncm\n2025-01-29 12:20:00+00:00\n1040.0\nmeting\n\n\n149\n1\nPannerdense-kop(PANN)\nPannerdense kop\n4724\nWATHTE\nWaterhoogte Oppervlaktewater t.o.v. Normaal Am...\ncm\n2025-01-29 12:30:00+00:00\n1040.0\nmeting\n\n\n150\n1\nPannerdense-kop(PANN)\nPannerdense kop\n4724\nWATHTE\nWaterhoogte Oppervlaktewater t.o.v. Normaal Am...\ncm\n2025-01-29 12:40:00+00:00\n1040.0\nmeting\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n571\n1\nPannerdense-kop(PANN)\nPannerdense kop\n4724\nWATHTE\nWaterhoogte verwacht Oppervlaktewater t.o.v. N...\ncm\n2025-02-01 05:20:00+00:00\n1099.0\nverwachting\n\n\n572\n1\nPannerdense-kop(PANN)\nPannerdense kop\n4724\nWATHTE\nWaterhoogte verwacht Oppervlaktewater t.o.v. N...\ncm\n2025-02-01 05:30:00+00:00\n1099.0\nverwachting\n\n\n573\n1\nPannerdense-kop(PANN)\nPannerdense kop\n4724\nWATHTE\nWaterhoogte verwacht Oppervlaktewater t.o.v. N...\ncm\n2025-02-01 05:40:00+00:00\n1100.0\nverwachting\n\n\n574\n1\nPannerdense-kop(PANN)\nPannerdense kop\n4724\nWATHTE\nWaterhoogte verwacht Oppervlaktewater t.o.v. N...\ncm\n2025-02-01 05:50:00+00:00\n1100.0\nverwachting\n\n\n575\n1\nPannerdense-kop(PANN)\nPannerdense kop\n4724\nWATHTE\nWaterhoogte verwacht Oppervlaktewater t.o.v. N...\ncm\n2025-02-01 06:00:00+00:00\n1100.0\nverwachting\n\n\n\n\n430 rows × 10 columns\n\n\n\n\n\nLaad en run module (functie) LoadsFEWS voor inlezen belastingen uit FEWS\nLET OP: zoek op basis van een measurement_location_code die in FEWS overeenkomt met ‘locationId’ \nFews is niet extern bereikbaar\n\n# from toolbox_continu_inzicht.loads import LoadsFews\n\n# fews = LoadsFews(data_adapter=data)\n# ds = fews.run(input=\"BelastingLocaties_FEWS\", output=\"Waterstanden_FEWS\")\n\n\n# measuringlocations = fews.df_in\n# measuringlocations\n\n\n# waterlevels = fews.df_out\n# waterlevels\n\n\n\nLaad en run module (functie) LoadsMatroos voor inlezen belastingen uit Matroos\nLET OP: zoek op basis van een measurement_location_code die in (NOOS) Matroos overeenkomt met ‘Location’ -&gt; loc_id!\n\nfrom toolbox_continu_inzicht.loads import LoadsMatroos\n\nmatroos = LoadsMatroos(data_adapter=data)\nds = matroos.run(input=\"BelastingLocaties_Matroos\", output=\"Waterstanden_Matroos\")\n\n\nmeasuringlocations = matroos.df_in\nmeasuringlocations\n\n\n\n\n\n\n\n\nmeasurement_location_id\nmeasurement_location_code\nmeasurement_location_description\nsource\ntide\n\n\n\n\n2\n3\nHoek van Holland\nHoek van Holland\nNOOS Matroos\nTrue\n\n\n\n\n\n\n\n\nwaterlevels = matroos.df_out\nwaterlevels\n\n\n\n\n\n\n\n\nmeasurement_location_id\nmeasurement_location_code\nmeasurement_location_description\nparameter_id\nparameter_code\ndate_time\nunit\nvalue\nvalue_type\n\n\n\n\n0\n3\nHoek van Holland\nHoek van Holland\n4724\nWATHTE\n2025-01-29 12:00:00+00:00\ncm\n36.10\nmeting\n\n\n1\n3\nHoek van Holland\nHoek van Holland\n4724\nWATHTE\n2025-01-29 12:10:00+00:00\ncm\n52.69\nmeting\n\n\n2\n3\nHoek van Holland\nHoek van Holland\n4724\nWATHTE\n2025-01-29 12:20:00+00:00\ncm\n72.40\nmeting\n\n\n3\n3\nHoek van Holland\nHoek van Holland\n4724\nWATHTE\n2025-01-29 12:30:00+00:00\ncm\n92.71\nmeting\n\n\n4\n3\nHoek van Holland\nHoek van Holland\n4724\nWATHTE\n2025-01-29 12:40:00+00:00\ncm\n110.45\nmeting\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n410\n3\nHoek van Holland\nHoek van Holland\n4724\nWATHTE\n2025-02-01 08:20:00+00:00\ncm\n-99.81\nverwachting\n\n\n411\n3\nHoek van Holland\nHoek van Holland\n4724\nWATHTE\n2025-02-01 08:30:00+00:00\ncm\n-102.60\nverwachting\n\n\n412\n3\nHoek van Holland\nHoek van Holland\n4724\nWATHTE\n2025-02-01 08:40:00+00:00\ncm\n-103.06\nverwachting\n\n\n413\n3\nHoek van Holland\nHoek van Holland\n4724\nWATHTE\n2025-02-01 08:50:00+00:00\ncm\n-102.48\nverwachting\n\n\n414\n3\nHoek van Holland\nHoek van Holland\n4724\nWATHTE\n2025-02-01 09:00:00+00:00\ncm\n-99.04\nverwachting\n\n\n\n\n415 rows × 9 columns\n\n\n\n\n\nLaad en run module (functie) LoadsWaterwebservicesRWS voor inlezen belastingen uit RWS Waterwebservices\nLET OP: zoek op basis van een measurement_location_code die in RWS WaterWebservices overeenkomt met Locatie_MessageID!\n\n\nfrom toolbox_continu_inzicht.loads import LoadsWaterwebservicesRWS\n\nwaterwebservices_rws = LoadsWaterwebservicesRWS(data_adapter=data)\nds = waterwebservices_rws.run(\n    input=\"BelastingLocaties_Waterwebservices_RWS\",\n    output=\"Waterstanden_Waterwebservices_RWS\",\n)\n\n\nmeasuringlocations = waterwebservices_rws.df_in\nmeasuringlocations\n\n\n\n\n\n\n\n\nmeasurement_location_id\nmeasurement_location_code\nmeasurement_location_description\nsource\ntide\n\n\n\n\n3\n4\n9889\nHintham beneden\nRWS Waterwebservices\nFalse\n\n\n\n\n\n\n\n\nwaterlevels = waterwebservices_rws.df_out\nwaterlevels\n\n\n\n\n\n\n\n\nmeasurement_location_id\nmeasurement_location_code\nmeasurement_location_description\nparameter_id\nparameter_code\ndate_time\nunit\nvalue\nvalue_type\n\n\n\n\n0\n4\n9889\nHintham beneden\n4724\nWATHTE\n2025-01-29 13:00:00+01:00\ncm\n203.0\nmeting\n\n\n1\n4\n9889\nHintham beneden\n4724\nWATHTE\n2025-01-29 13:10:00+01:00\ncm\n205.0\nmeting\n\n\n2\n4\n9889\nHintham beneden\n4724\nWATHTE\n2025-01-29 13:20:00+01:00\ncm\n206.0\nmeting\n\n\n3\n4\n9889\nHintham beneden\n4724\nWATHTE\n2025-01-29 13:30:00+01:00\ncm\n202.0\nmeting\n\n\n4\n4\n9889\nHintham beneden\n4724\nWATHTE\n2025-01-29 13:40:00+01:00\ncm\n207.0\nmeting\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n142\n4\n9889\nHintham beneden\n4724\nWATHTE\n2025-01-30 12:40:00+01:00\ncm\n204.0\nmeting\n\n\n143\n4\n9889\nHintham beneden\n4724\nWATHTE\n2025-01-30 12:50:00+01:00\ncm\n205.0\nmeting\n\n\n144\n4\n9889\nHintham beneden\n4724\nWATHTE\n2025-01-30 13:00:00+01:00\ncm\n209.0\nmeting\n\n\n145\n4\n9889\nHintham beneden\n4724\nWATHTE\n2025-01-30 13:10:00+01:00\ncm\n202.0\nverwachting\n\n\n146\n4\n9889\nHintham beneden\n4724\nWATHTE\n2025-01-30 13:20:00+01:00\ncm\n204.0\nverwachting\n\n\n\n\n147 rows × 9 columns\n\n\n\n\n\nGrafische weergave van resultaten in 4 grafieken",
    "crumbs": [
      "Belastingen inladen"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Toolbox Continu Inzicht",
    "section": "",
    "text": "Waterkeringbeheerders zijn gewend om hun waterkeringen te laten voldoen aan vastgestelde normen: daar baseren ze het ontwerp en hun beheer en onderhoud op. In een situatie met extreme droogte of extreem hoge waterstanden is er meer nodig. Dan is het belangrijk continu inzicht te hebben in de actuele risico’s voor het gebied in de eerstvolgende dagen. De methode ‘continu inzicht’ is precies daarop gericht: ervoor zorgen dat de beheerder 24/7 in control is. Met slimme monitoring en rekenmodellen wordt de actuele situatie geanalyseerd. De beheerder ziet hoe groot het risico is en waar de zwakke plekken zitten, zodat hij of zij gericht maatregelen kan nemen. De ‘Toolbox Continu Inzicht’ is door HKV lijn in water ontwikkeld voor waterschappen en Rijkswaterstaat. Door middel van deze toolbox worden de systemen achter ‘continu inzicht’ herontwikkeld in python en open source aangeboden."
  },
  {
    "objectID": "modules/architectuur.html",
    "href": "modules/architectuur.html",
    "title": "Basis architectuur Toolbox Continu Inzicht",
    "section": "",
    "text": "De architectuur van de Toolbox Continu Inzicht is ontworpen om flexibel te zijn.\n\nConfiguratie\nPer systeem kunnen de wensen van de gebruiker veranderen. Het systeem is dan ook te configureren voor verschillende databronnen. Door middel van een yaml configuratiebestand wordt de juist informatie meegegeven aan de modules en de data-adapter.\nHet kopje GlobalVariables is verplicht met minimaal een rootdir: dit is een map waarin de data bestanden staan en weggeschreven worden. De DataAdapter is ook verplicht, met minimaal één data adapter. De naam van de data adapter is vrij te kiezen. Er kunnen zoveel data adapters aangemaakt worden als gewenst.\nGlobalVariables:\n    rootdir: \"C:/data/toobox/\"\n\nDataAdapter:\n    EenTypeDataAdapter:\n        type: csv\n        file: \"eerste_voorbeeld.csv\"\nOnder GlobalVariables kan per datatype een variabele worden meegegeven die voor alle adapters van dit type gelden. Voor csv kan dit bijvoorbeeld het scheidingsteken zijn. Alle data adapters met het type csv krijgen nu de extra variabele mee.\nGlobalVariables:\n    rootdir: \"C:/data/toobox/\"\n\nDataAdapter:\n    default_options:\n        csv:\n            sep: \";\"\n    EenTypeDataAdapter:\n        type: csv\n        file: \"eerste_voorbeeld.csv\"\n    CSV_output:\n        type: csv\n        file: \"voorbeeld_output.csv\"\nNaast de data-adapters worden modules ook geconfigureerd in de GlobalVariables. Zo worden de opties voor de module LoadsMatroos ook mee gegeven in de GlobalVariables.\nGlobalVariables:\n    rootdir: \"C:/data/toobox/\"\n\n    LoadsMatroos:\n        website: \"noos\"\n        source: \"dcsm6_kf\"\n        parameters: [\"waterlevel\"]\n        MISSING_VALUE: 999\n\nDataAdapter:\n    ...\nDe tijd waarop de berekening van de toolbox plaatsvindt is ook te configureren met calc_time. Deze tijd moet in het ISO 8601 format zijn en wordt uitgelezen met datetime.datetime.fromisoformat. Indien geen tijd wordt meegegeven, maakt de Config klasse deze zelf aan met het tijdstip van runnen.\nGlobalVariables:\n    rootdir: \"C:/data/toobox/\"\n    calc_time: '2024-11-18 08:00:00'\n\n    LoadsMatroos:\n        website: \"noos\"\n        source: \"dcsm6_kf\"\n        parameters: [\"waterlevel\"]\n        MISSING_VALUE: 999\n\nDataAdapter:\n    ...\n\n\nData-adapter\nDe data-adapter wordt gebruikt om verschillende datatypes in en uit te lezen. Op dit moment zijn dit de volgende dataformaten:\n\nCSV\nNetCDF\nPostgreSQL\n\nDeze wordt geconfigureerd in de een .yaml configuratiebestand. Een voorbeeld van een csv-bestand wordt hieronder weergegeven. Hierbij zijn type en file of path verplicht. In het voorbeeld hieronder wordt een relatief pad meegegeven als rootdir, dit wordt ook ondersteund.\nGlobalVariables:\n    rootdir: \"data_sets\"\n\nDataAdapter:\n    my_csv_in:\n        type: csv\n        file: \"test_csv_in.csv\"\n    my_csv_out:\n        type: csv\n        file: \"test_csv_out.csv\"\n...\nIndien een bestand buiten de root directory valt kan in plaats van file ook een absoluut path worden meegegeven.\nDataAdapter:\n    MyCSV_anders:\n        type: csv\n        path: \"C:/data/Ander/pad_naar_csv.csv\"\n...\nNaast de verplichte waardes van een data-adapter worden ook alle overige opties doorgegeven. Voor de generieke data-adapters is er een check of de extra opgegeven opties ondersteund worden. Zo maakt de csv data adapter gebruik van pandas.read_csv en de NetCDF data adapter xarray.open_dataset. Voor PostgreSQL zijn alleen drie standaard opties beschikbaar: database, schema en table.\n\nAdapters aanmaken vanuit Python\nNaast het definiëren van data adapters via het configuratiebestand, kan dit ook vanuit Python zelf gedaan worden met de functie set_dataframe_adapter.\nDit kan op twee manieren:\n\nDe data adapter wordt vooraf in de configuratie opgegeven met het type Python. De functie geeft het desbetreffende dataframe door.\nEr is geen data-adapter gedefinieerd. Deze wordt aangemaakt bij het runnen van de code. Let op: het configuratiebestand verandert niet mee.\n\nOptie 1:\n\nConfiguratieCode\n\n\nGlobalVariables:\n    rootdir: \"data_sets\"\n\nDataAdapter:\n    my_df_in:\n        type: python\n...\n\n\nconfig = Config(config_path=\"config.yaml\")\nconfig.lees_config()\ndata_adapter = DataAdapter(config=config)\ndata_adapter.set_dataframe_adapter(\"my_df_in\", input_df, if_not_exist=\"raise\")\n...\n\n\n\nOptie 2:\n\nConfiguratieCode\n\n\nGlobalVariables:\n    rootdir: \"data_sets\"\n\nDataAdapter:\n    my_csv_in:\n        type: csv\n        file: \"test_csv_in.csv\"\n...\n\n\nconfig = Config(config_path=\"config.yaml\")\nconfig.lees_config()\ndata_adapter = DataAdapter(config=config)\ndata_adapter.set_dataframe_adapter(\"my_new_data_adapter\", input_df, if_not_exist=\"create\")\n\n\n\n\n\n\nWachtwoorden\nVoor bepaalde diensten, zoals het toegang krijgen tot een database, is een wachtwoord vereist. Deze kunnen in de “environmental variables” worden meegegeven, in de vorm van een .env bestand.\npostgresql_host=\"xxx.xx.xx.xx\"\npostgresql_database=\"xxxxxxx\"\npostgresql_port=\"xxxx\"\npostgresql_password=\"xxxx\"\npostgresql_user=\"xx\"",
    "crumbs": [
      "Modules",
      "Basis architectuur Toolbox Continu Inzicht"
    ]
  },
  {
    "objectID": "modules/bepalen_fragility_curves.html",
    "href": "modules/bepalen_fragility_curves.html",
    "title": "Bepalen fragility curves",
    "section": "",
    "text": "De continu inzicht toolbox heeft de functionaliteit om fragility curves voor verschillende faalmechanisme uit te rekenen. Deze sectie beschrijft de beschikbare functies per type faalmechanisme. In Toolbox Continu Inzicht zijn 3 verschillende type fragility curves: GEKB, STPH en alle overige curves. Deze worden in het figuur hieronder weer gegeven.\n\n\n\nOverzicht van verschillende fragilityCurves in Toolbox Continu Inzicht\n\n\nGolfoverslag Erosie Kruin en Binnentalud (GEKB) kunnen ‘on-the-fly’ worden berekend, afhankelijk van verschillende factoren kunnen deze worden aangepast. Voor SPTH kunnen curves vastgesteld worden met de beschikbare functionaliteit, maar dit moet vooraf plaatsvinden. Dit komt door een langere rekentijd en vanwege kwaliteitscontrole. Alle andere curves kunnen niet berekend worden binnen Toolbox Continu\n\nGolfoverslag Erosie Kruin en Binnentalud (GEKB)\nVoor het bereken van fragility curves voor GEKB wordt gebruik gemaakt van de Python module pydra-core. Deze losstaande Python module is ontwikkeld door HKV en openbaar beschikbaar gemaakt op GitHub. De documentatie is op deze GitHub pagina te vinden\nEen fragility curve kan berekend door de functie FragilityCurveOvertopping aan te roepen. Hier zijn drie dataframes voor nodig: de eerste met informatie over de hellingen, de tweede over het profiel en als laatste informatie over de bodem en strijklengte. Voor de berekening wordt model onzekerheid mee genomen. Hiervoor zijn acht standaard waardes gebruikt voor bretschneider waarmee golf hoogte en periode worden bepaald. Deze kunnen aangepast worden als opties in de config.yaml, zo als te zien in het voorbeeld met gh_onz_mu. Naast onzekerheden kan ook de verhouding tussen de piek periode van de golf ($T_p$) en de spectrale golfperiode ($Tm_{-1,0}$) worden aangepast met tp_tspec (standaard 1.1). Ook zijn er reken instellingen waarmee wordt gerekend. Hier zijn nog vier instellingen die aangepast kunnen worden. De waterniveaus waarmee probabilistisch gerekend wordt is verdeelt in twee delen: grof en fijn. Standaard zijn fijne stappen van 2m (upper_limit_coarse) onder de kruin tot 1.01m (upper_limit_fine) boven de kruin met stappen van 0.05 (hstap). Standaard grove stappen lopen van 4m (lower_limit_coarse) onder de kruin tot 2m (upper_limit_coarse) onder de kruin met stappen van twee keer zo groot (2 * hstap = 0.1). Al deze variable zijn los te configureren, als er niks wordt opgegeven, worden de standaard genoemde waardes gebruikt.\n\nConfiguratieCode\n\n\nGlobalVariables:\n    rootdir: \"data_sets\"\n\n    FragilityCurveOvertopping:\n        # default waardes, kunnen worden overschreven\n        gh_onz_mu: 0.96\n        gh_onz_sigma: 0.27\n        gp_onz_mu_tp: 1.03\n        gp_onz_sigma_tp: 0.13\n        gp_onz_mu_tspec: 1.03\n        gp_onz_sigma_tspec: 0.13\n        gh_onz_aantal: 7\n        gp_onz_aantal: 7\n        tp_tspec: 1.1\n        lower_limit_coarse: 4.0\n        upper_limit_coarse: 2.0\n        upper_limit_fine: 1.0\n        hstap: 0.05\n\nDataAdapter:\n    default_options:\n        csv:\n            sep: \",\"\n    slopes:\n        type: csv\n        file: \"slopes.csv\"\n    profiles:\n        type: csv\n        file: \"profiles.csv\"\n    bedlevel_fetch:\n        type: csv\n        file: \"bedlevelfetch.csv\"\n    fragility_curves:\n        type: csv\n        file: \"fragility_curves.csv\"\n\n\nfrom toolbox_continu_inzicht import Config, DataAdapter\nfrom toolbox_continu_inzicht.fragility_curves import FragilityCurveOvertopping\n\nconfig = Config(config_path=\"config.yaml\")\nconfig.lees_config()\ndata_adapter = DataAdapter(config=config)\nfragility_curve_overtopping = FragilityCurveOvertopping(data_adapter=data_adapter)\nfragility_curve_overtopping.run(\n    input=[\"slopes\", \"profiles\", \"bedlevel_fetch\"],\n    output=\"fragility_curves\",\n)\n\n\n\n\n\nPiping (STPH)\nVoor het bereken van fragility curves voor piping (STPH) wordt gebruik gemaakt van de python module probabilistic_piping. Deze los staande python module is ontwikkeld door HKV en is voor toolbox continu inzicht openbaar beschikbaar gemaakt op GitHub. De documentatie van deze module is daar ook te vinden.\n\nDisclaimer:\n\nDe uitvoer van 'probabilistic-piping' geeft meer informatie over of een som in de berekening is gelukt, hier worden echter binnen Toolbox Continu Inzicht geen checks op gedaan. Het is aan de gebruiker om na te lopen of de curve die wordt gegenereerd daadwerkelijk logisch is.\n\n\n\nFragilityCurvePipingFixedWaterlevelSimple\nDe functie FragilityCurvePipingFixedWaterlevelSimple rekent met de drie sub-mechanismes uplift, heave, Sellmeijer en geeft een gecombineerde curve terug. Het combineren gebeurt hier door het minimum van de kansen per sub mechanisme te nemen. De curves van de sub-mechanismes zijn beschikbaar via dedf_result_uplift, df_result_heave, en df_result_sellmeijer attributen.\n\nConfiguratieCode\n\n\nGlobalVariables:\n    rootdir: \"data_sets\"\n\n    FragilityCurvePipingFixedWaterlevelSimple:\n        debug: False\n        progress: True\n\n\nDataAdapter:\n    default_options:\n        csv:\n            sep: \",\"\n\n    probabilistic_input:\n        type: excel\n        file: \"invoer_piping.xlsx\"\n        index_col: 0\n    waterlevels:\n        type: csv\n        file: \"waterlevels.csv\"\n    fragility_curve:\n        type: csv\n        file: \"fragility_curves_piping.csv\"\n\n\n\nfrom toolbox_continu_inzicht import Config, DataAdapter\nfrom toolbox_continu_inzicht.fragility_curves import FragilityCurvePipingFixedWaterlevelSimple\n\nconfig = Config(config_path=\"config.yaml\")\nconfig.lees_config()\ndata_adapter = DataAdapter(config=config)\nfragility_curve_piping_fixed_waterlevel = FragilityCurvePipingFixedWaterlevelSimple(data_adapter=data_adapter)\nfragility_curve_piping_fixed_waterlevel.run(\n    input=[\"probabilistic_input\", \"waterlevels\"],\n    output=\"fragility_curves\",\n)\n\n\n\n\n\n\nCombineren van fragility curves\nFragility curves kunnen op drie manieren worden gecombineerd: Afhankelijk, onafhankelijk of met een gewogen gemiddelde. De tabel hieronder geeft hier een overzicht van.\n\n\n\n\n\n\n\n\nType\nFunctie\nFormule\n\n\n\n\nAfhankelijk\nCombineFragilityCurvesIndependent\n\\(P(fail,comb|h)=1-prod(1-P(fail,i|h))\\)\n\n\nOnafhankelijk\nCombineFragilityCurvesDependent\n\\(P(fail,comb|h)=max(P(fail,i|h))\\)\n\n\nGewogen gemiddelde\nCombineFragilityCurvesWeightedSum\n\\(P(fail,comb|h)=\\sum_{i=1}^{n}(w_i*P(fail,i|h))\\)\n\n\n\nAlle drie de functies verwachten een lijst met namen van de data adapters van de fragility curves die gecombineerd moeten worden. Bij de gewogen gemiddelde functie moet de laatste data adapter de gewichten bevatten waarmee de fragility curves worden gecombineerd. De gewichten dataframe moet een kolom met ‘weights’ hebben, er is met opzet geen validatie of deze gewichten optellen tot 1 zodat de curve ook geschaald kan worden. De tabel hieronder geeft weer hoe de gewichten table er uit moet zien.\n\n\n\nweights\n\n\n\n\n0.6\n\n\n0.4\n\n\n\nBij het combineren van de fragility curves moeten de waterstanden van de curves op elkaar afgestemd worden. Dit wordt gedaan op basis van de waterniveaus, en nog twee parameters: hoe ver voorbij de hoogste waarde extend_past_max (standaard waarde is 0.01) en met welke stap grootte refine_step_size (standaard waarde is 0.05)\n\nConfiguratie (on)afhankelijkCode (on)afhankelijkConfiguratie gewogen gemiddeldeCode gewogen gemiddelde\n\n\nGlobalVariables:\n    rootdir: \"data_sets\"\n\nDataAdapter:\n    fragility_curve_piping_csv:\n        type: csv\n        file: \"fragility_curve_piping.csv\"\n\n    fragility_curve_overtopping_csv:\n        type: csv\n        file: \"fragility_curve_overtopping.csv\"\n\n    fragility_curves:\n        type: csv\n        file: \"fragility_curve_combined.csv\"\n\n\nfrom toolbox_continu_inzicht import Config, DataAdapter\n\nconfig = Config(config_path=\"config.yaml\")\nconfig.lees_config()\ndata_adapter = DataAdapter(config=config)\n\nfrom toolbox_continu_inzicht.fragility_curves import CombineFragilityCurvesIndependent\n\ncombine_fragility_curve = CombineFragilityCurvesIndependent(data_adapter=data_adapter)\ncombine_fragility_curve.run(\n    input=[\"fragility_curve_piping_csv\", \"fragility_curve_overtopping_csv\"],\n    output=\"fragility_curves\",\n)\n\nfrom toolbox_continu_inzicht.fragility_curves import CombineFragilityCurvesDependent\n\ncombine_fragility_curve_dep = CombineFragilityCurvesDependent(data_adapter=data_adapter)\ncombine_fragility_curve_dep.run(\n    input=[\"fragility_curve_piping_csv\", \"fragility_curve_overtopping_csv\"],\n    output=\"fragility_curves\",\n)\n\n\nGlobalVariables:\n    rootdir: \"data_sets\"\n\nDataAdapter:\n    fragility_curve_piping_csv:\n        type: csv\n        file: \"fragility_curve_piping.csv\"\n\n    fragility_curve_overtopping_csv:\n        type: csv\n        file: \"fragility_curve_overtopping.csv\"\n\n    weighting_factor_csv:\n        type: csv\n        file: \"weighting_factor_combine.csv\"\n\n    fragility_curves:\n        type: csv\n        file: \"fragility_curve_combined.csv\"\n\n\n\nfrom toolbox_continu_inzicht import Config, DataAdapter\nfrom toolbox_continu_inzicht.fragility_curves import CombineFragilityCurvesWeightedSum\n\nconfig = Config(config_path=\"config.yaml\")\nconfig.lees_config()\ndata_adapter = DataAdapter(config=config)\ncombine_fragility_curve = CombineFragilityCurvesWeightedSum(data_adapter=data_adapter)\ncombine_fragility_curve.run(\n    input=[\"fragility_curve_piping_csv\", \"fragility_curve_overtopping_csv\", \"weighting_factor_csv\"],\n    output=\"fragility_curves\",\n)",
    "crumbs": [
      "Modules",
      "Bepalen fragility curves"
    ]
  },
  {
    "objectID": "modules/digitale_delta_API.html",
    "href": "modules/digitale_delta_API.html",
    "title": "Digitale Delta API",
    "section": "",
    "text": "In ontwikkeling.",
    "crumbs": [
      "Modules",
      "Digitale Delta API"
    ]
  },
  {
    "objectID": "modules/inspectieresultaten.html",
    "href": "modules/inspectieresultaten.html",
    "title": "Inspectieresultaten inlezen en weergeven",
    "section": "",
    "text": "In ontwikkeling.",
    "crumbs": [
      "Modules",
      "Inspectieresultaten inlezen en weergeven"
    ]
  },
  {
    "objectID": "modules_index.html",
    "href": "modules_index.html",
    "title": "Modules",
    "section": "",
    "text": "De Toolbox Continu Inzicht wordt incrementeel ontwikkeld. De IT-ontwikkeling is opgedeeld in sprintblokken. Binnen elk sprintblok worden één of meerdere modules ontwikkeld. Voor elke module worden Python-scripts ontwikkeld waarmee een functie kan worden uitgevoerd. Een voorbeeld van een functie is het inlezen van waterstanden uit FEWS. De scripts en de code (inclusief documentatie) worden na het afronden van iedere sprint gepubliceerd op deze Wikipagina en een publieke GitHub. De scripts worden vrijgegeven nadat deze succesvol het testprotocol hebben doorlopen.\nDe ontwikkeling van de volgende modules is voorzien:\n\nBasis architectuur Toolbox Continu Inzicht\nIn de toolbox continu inzicht is een belangrijk uitgangspunt dat verschillende data formaten gebruikt kunnen worden, de functie zijn zo opgezet dat elk formaat als in of uitvoer kan dienen.\nBelastingen inlezen en classificeren\nOm inzicht te krijgen in de veiligheid van waterkeringen is het van belang om de belastingen op de waterkeringen in kaart te brengen. Dit kunnen waterstanden op het buitenwater (zee, rivieren of meren) zijn, maar ook grondwaterstanden. Er zijn verschillende functies geïmplementeerd voor het inlezen, opslaan en classificeren van historische en voorspelde belastingen.\nBepalen fragility curves\nFragility curves kunnen voor verschillende faalmechanismes worden berekend. In de toolbox wordt voor STPH (piping) en GEKB (golf overlag) functionaliteit aangeboden voor het afleiden van curves.\n\nIn ontwikkeling:\n\nBijstellen fragility curves (beheerdersoordeel in voorbereiding)\nConditionele kansen en status waterkering per sectie\nZorgplicht LBO2: effect nieuwe statistiek en rekenregels op de faalkans\nInspectieresultaten inlezen en weergeven\nResultaten ontsluiten via Digitale Delta API",
    "crumbs": [
      "Modules"
    ]
  },
  {
    "objectID": "reference/CombineFragilityCurvesDependent.html",
    "href": "reference/CombineFragilityCurvesDependent.html",
    "title": "CombineFragilityCurvesDependent",
    "section": "",
    "text": "fragility_curves.CombineFragilityCurvesDependent()\nCombineer meerdere fragility curves afhankelijk tot een enkele fragility curves.\nArgs: data_adapter (DataAdapter): DataAdapter object\n\n\nBij het combineren van de fragility curves moeten de waterstanden van de curves op elkaar afgestemd worden. Dit gebeurt door de waterstanden van de curves te interpoleren naar een nieuwe set waterstanden. De volgende opties kunnen worden ingesteld: - extend_past_max: float Hoever de nieuwe waterstanden verder gaan dan de maximale waterstanden van de input curves. Default is 0.01\n\nrefine_step_size: float De stapgrootte van de waterstanden die gebruikt wordt bij het herschalen van de kansen voor het combineren. Default is 0.05\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\nlst_fragility_curves\n\n\n\nweights\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalculate_combined_curve\n\n\n\ncombine_func\nCombineer afhankelijk: P(fail,comb|h) = MAX(P(fail,i|h))\n\n\nrun\n\n\n\n\n\n\nfragility_curves.CombineFragilityCurvesDependent.calculate_combined_curve(\n    extend_past_max\n    refine_step_size\n)\n\n\n\nfragility_curves.CombineFragilityCurvesDependent.combine_func(\n    lst_fragility_curves\n    **kwargs\n)\nCombineer afhankelijk: P(fail,comb|h) = MAX(P(fail,i|h))\n\n\n\nfragility_curves.CombineFragilityCurvesDependent.run(input, output)\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\nLijst van namen van de data adapters met fragility curves.\nrequired\n\n\noutput\nstr\nNaam van de output data adapter.\nrequired\n\n\n\n\n\n\nElke fragility curve moet de volgende kolommen bevatten: - waterlevels: float - failure_probabilities: float"
  },
  {
    "objectID": "reference/CombineFragilityCurvesDependent.html#options-in-config",
    "href": "reference/CombineFragilityCurvesDependent.html#options-in-config",
    "title": "CombineFragilityCurvesDependent",
    "section": "",
    "text": "Bij het combineren van de fragility curves moeten de waterstanden van de curves op elkaar afgestemd worden. Dit gebeurt door de waterstanden van de curves te interpoleren naar een nieuwe set waterstanden. De volgende opties kunnen worden ingesteld: - extend_past_max: float Hoever de nieuwe waterstanden verder gaan dan de maximale waterstanden van de input curves. Default is 0.01\n\nrefine_step_size: float De stapgrootte van de waterstanden die gebruikt wordt bij het herschalen van de kansen voor het combineren. Default is 0.05"
  },
  {
    "objectID": "reference/CombineFragilityCurvesDependent.html#attributes",
    "href": "reference/CombineFragilityCurvesDependent.html#attributes",
    "title": "CombineFragilityCurvesDependent",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\nlst_fragility_curves\n\n\n\nweights"
  },
  {
    "objectID": "reference/CombineFragilityCurvesDependent.html#methods",
    "href": "reference/CombineFragilityCurvesDependent.html#methods",
    "title": "CombineFragilityCurvesDependent",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncalculate_combined_curve\n\n\n\ncombine_func\nCombineer afhankelijk: P(fail,comb|h) = MAX(P(fail,i|h))\n\n\nrun\n\n\n\n\n\n\nfragility_curves.CombineFragilityCurvesDependent.calculate_combined_curve(\n    extend_past_max\n    refine_step_size\n)\n\n\n\nfragility_curves.CombineFragilityCurvesDependent.combine_func(\n    lst_fragility_curves\n    **kwargs\n)\nCombineer afhankelijk: P(fail,comb|h) = MAX(P(fail,i|h))\n\n\n\nfragility_curves.CombineFragilityCurvesDependent.run(input, output)\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\nLijst van namen van de data adapters met fragility curves.\nrequired\n\n\noutput\nstr\nNaam van de output data adapter.\nrequired\n\n\n\n\n\n\nElke fragility curve moet de volgende kolommen bevatten: - waterlevels: float - failure_probabilities: float"
  },
  {
    "objectID": "reference/CombineFragilityCurvesWeightedSum.html",
    "href": "reference/CombineFragilityCurvesWeightedSum.html",
    "title": "CombineFragilityCurvesWeightedSum",
    "section": "",
    "text": "fragility_curves.CombineFragilityCurvesWeightedSum()\nCombineer meerdere fragility curves met een gewogen som tot een enkele fragility curves.\nArgs: data_adapter (DataAdapter): DataAdapter object\n\n\nBij het combineren van de fragility curves moeten de waterstanden van de curves op elkaar afgestemd worden. Dit gebeurt door de waterstanden van de curves te interpoleren naar een nieuwe set waterstanden. De volgende opties kunnen worden ingesteld: - extend_past_max: float Hoever de nieuwe waterstanden verder gaan dan de maximale waterstanden van de input curves. Default is 0.01\n\nrefine_step_size: float De stapgrootte van de waterstanden die gebruikt wordt bij het herschalen van de kansen voor het combineren. Default is 0.05\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\nlst_fragility_curves\n\n\n\nweights\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncalculate_combined_curve\n\n\n\ncombine_func\nCombineer afhankelijk: P(fail,comb|h) = SUM(w_i * P(fail,i|h))\n\n\nrun\n\n\n\n\n\n\nfragility_curves.CombineFragilityCurvesWeightedSum.calculate_combined_curve(\n    extend_past_max\n    refine_step_size\n)\n\n\n\nfragility_curves.CombineFragilityCurvesWeightedSum.combine_func(\n    lst_fragility_curves\n    weights=None\n)\nCombineer afhankelijk: P(fail,comb|h) = SUM(w_i * P(fail,i|h))\n\n\n\nfragility_curves.CombineFragilityCurvesWeightedSum.run(input, output)\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\nLijst van namen van de data adapters met fragility curves. De laatste lijst hiervan in de gewichten.\nrequired\n\n\noutput\nstr\nNaam van de output data adapter.\nrequired\n\n\n\n\n\n\nElke fragility curve moet de volgende kolommen bevatten: - waterlevels: float - failure_probabilities: float\nDe laatste fragility curve in de input lijst bevat de gewichten.\nDeze moet de volgende kolom bevatten:\n- weights: float\n\n    per curve de gewichten"
  },
  {
    "objectID": "reference/CombineFragilityCurvesWeightedSum.html#options-in-config",
    "href": "reference/CombineFragilityCurvesWeightedSum.html#options-in-config",
    "title": "CombineFragilityCurvesWeightedSum",
    "section": "",
    "text": "Bij het combineren van de fragility curves moeten de waterstanden van de curves op elkaar afgestemd worden. Dit gebeurt door de waterstanden van de curves te interpoleren naar een nieuwe set waterstanden. De volgende opties kunnen worden ingesteld: - extend_past_max: float Hoever de nieuwe waterstanden verder gaan dan de maximale waterstanden van de input curves. Default is 0.01\n\nrefine_step_size: float De stapgrootte van de waterstanden die gebruikt wordt bij het herschalen van de kansen voor het combineren. Default is 0.05"
  },
  {
    "objectID": "reference/CombineFragilityCurvesWeightedSum.html#attributes",
    "href": "reference/CombineFragilityCurvesWeightedSum.html#attributes",
    "title": "CombineFragilityCurvesWeightedSum",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_out\n\n\n\nlst_fragility_curves\n\n\n\nweights"
  },
  {
    "objectID": "reference/CombineFragilityCurvesWeightedSum.html#methods",
    "href": "reference/CombineFragilityCurvesWeightedSum.html#methods",
    "title": "CombineFragilityCurvesWeightedSum",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncalculate_combined_curve\n\n\n\ncombine_func\nCombineer afhankelijk: P(fail,comb|h) = SUM(w_i * P(fail,i|h))\n\n\nrun\n\n\n\n\n\n\nfragility_curves.CombineFragilityCurvesWeightedSum.calculate_combined_curve(\n    extend_past_max\n    refine_step_size\n)\n\n\n\nfragility_curves.CombineFragilityCurvesWeightedSum.combine_func(\n    lst_fragility_curves\n    weights=None\n)\nCombineer afhankelijk: P(fail,comb|h) = SUM(w_i * P(fail,i|h))\n\n\n\nfragility_curves.CombineFragilityCurvesWeightedSum.run(input, output)\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\nLijst van namen van de data adapters met fragility curves. De laatste lijst hiervan in de gewichten.\nrequired\n\n\noutput\nstr\nNaam van de output data adapter.\nrequired\n\n\n\n\n\n\nElke fragility curve moet de volgende kolommen bevatten: - waterlevels: float - failure_probabilities: float\nDe laatste fragility curve in de input lijst bevat de gewichten.\nDeze moet de volgende kolom bevatten:\n- weights: float\n\n    per curve de gewichten"
  },
  {
    "objectID": "reference/DataAdapter.html",
    "href": "reference/DataAdapter.html",
    "title": "DataAdapter",
    "section": "",
    "text": "DataAdapter()\nBasis DataAdapter\n\n\n\n\n\nName\nDescription\n\n\n\n\nconfig\n\n\n\ninput_types\n\n\n\noutput_types\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ninitialize_input_types\n\n\n\ninitialize_output_types\n\n\n\ninput\nGegeven het config, stuurt de juiste input waarde aan\n\n\noutput\nGegeven het config, stuurt de juiste input waarde aan\n\n\nset_dataframe_adapter\nFunctie om een dataframe mee te geven aan een data adapter met type: python.\n\n\nset_global_variable\nFunctie voor het dynamisch overschrijven van global variablen.\n\n\n\n\n\nDataAdapter.initialize_input_types()\n\n\n\nDataAdapter.initialize_output_types()\n\n\n\nDataAdapter.input(input, schema=None)\nGegeven het config, stuurt de juiste input waarde aan\n\n\ninput: str Naam van de data adapter die gebruikt wordt.\nopties: dict extra informatie die ook naar de functie moet om het bestand te lezen\n\n\n\n\nDataAdapter.output(output, df)\nGegeven het config, stuurt de juiste input waarde aan\n\n\noutput: name of the data adapter to use df: pd.Dataframe pandas dataframe om weg te schrijven\nopties: dict extra informatie die ook naar de functie moet om het bestand te schrijven\n\n\n\n\nDataAdapter.set_dataframe_adapter(key, df, if_not_exist='raise')\nFunctie om een dataframe mee te geven aan een data adapter met type: python. Let er zelf op dat de kollom namen en datatypes overeen komen met de beoogde functie.\n\n\nkey: str naam van de data adapter zoals opgegeven in de configuratie yaml\ndf: pd.Dataframe Object om mee te geven\nif_not_exist: str[raise, create] Geeft aan wat te doen als de data adapter niet bestaat, bij raise krijg je een error, bij create wordt er een nieuwe data adapter aangemaakt.\n\n\n\n\nDataAdapter.set_global_variable(key, value)\nFunctie voor het dynamisch overschrijven van global variablen.\n\n\nkey: str naam van de waarde om te overschrijven\nvalue: Any Object om mee te geven"
  },
  {
    "objectID": "reference/DataAdapter.html#attributes",
    "href": "reference/DataAdapter.html#attributes",
    "title": "DataAdapter",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nconfig\n\n\n\ninput_types\n\n\n\noutput_types"
  },
  {
    "objectID": "reference/DataAdapter.html#methods",
    "href": "reference/DataAdapter.html#methods",
    "title": "DataAdapter",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ninitialize_input_types\n\n\n\ninitialize_output_types\n\n\n\ninput\nGegeven het config, stuurt de juiste input waarde aan\n\n\noutput\nGegeven het config, stuurt de juiste input waarde aan\n\n\nset_dataframe_adapter\nFunctie om een dataframe mee te geven aan een data adapter met type: python.\n\n\nset_global_variable\nFunctie voor het dynamisch overschrijven van global variablen.\n\n\n\n\n\nDataAdapter.initialize_input_types()\n\n\n\nDataAdapter.initialize_output_types()\n\n\n\nDataAdapter.input(input, schema=None)\nGegeven het config, stuurt de juiste input waarde aan\n\n\ninput: str Naam van de data adapter die gebruikt wordt.\nopties: dict extra informatie die ook naar de functie moet om het bestand te lezen\n\n\n\n\nDataAdapter.output(output, df)\nGegeven het config, stuurt de juiste input waarde aan\n\n\noutput: name of the data adapter to use df: pd.Dataframe pandas dataframe om weg te schrijven\nopties: dict extra informatie die ook naar de functie moet om het bestand te schrijven\n\n\n\n\nDataAdapter.set_dataframe_adapter(key, df, if_not_exist='raise')\nFunctie om een dataframe mee te geven aan een data adapter met type: python. Let er zelf op dat de kollom namen en datatypes overeen komen met de beoogde functie.\n\n\nkey: str naam van de data adapter zoals opgegeven in de configuratie yaml\ndf: pd.Dataframe Object om mee te geven\nif_not_exist: str[raise, create] Geeft aan wat te doen als de data adapter niet bestaat, bij raise krijg je een error, bij create wordt er een nieuwe data adapter aangemaakt.\n\n\n\n\nDataAdapter.set_global_variable(key, value)\nFunctie voor het dynamisch overschrijven van global variablen.\n\n\nkey: str naam van de waarde om te overschrijven\nvalue: Any Object om mee te geven"
  },
  {
    "objectID": "reference/FragilityCurveOvertopping.html",
    "href": "reference/FragilityCurveOvertopping.html",
    "title": "FragilityCurveOvertopping",
    "section": "",
    "text": "fragility_curves.FragilityCurveOvertopping()\nMaakt een enkele fragility curve voor golf overslag.\nArgs: data_adapter (DataAdapter): DataAdapter object\n\n\nOnzekerheden: float - gh_onz_mu GolfHoogte onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfhoogte (standaard 0.96)\n- gh_onz_sigma\n    GolfHoogte onzekerheid sigma: standaard afwijking waarde (standaard 0.27)\n\n- gp_onz_mu_tp\n    GolfPerioden onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfperiode (standaard 1.03)\n\n- gp_onz_sigma_tp\n    GolfPerioden onzekerheid sigma: standaard afwijking waarde (standaard 0.13)\n\n- gp_onz_mu_tspec\n    GolfPerioden onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfperiode (standaard 1.03)\n\n- gp_onz_sigma_tspec\n    GolfPerioden onzekerheid sigma: standaard afwijking waarde (standaard 0.13)\n\n- gh_onz_aantal\n    Aantal onzekerheden in de golfhoogte (standaard 7)\n- gp_onz_aantal\n    Aantal onzekerheden in de golfperiode (standaard 7)\ntp_tspec: float de verhouding tussen de piek periode van de golf ($T_p$) en de spectrale golfperiode ($Tm_{-1,0}$) (standaard 1.1).\nDe waterniveaus waarmee probablistisch gerekend wordt is verdeelt in twee delen: grof en fijn.\nlower_limit_coarse: float De ondergrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in grove stappen (standaard 4.0m onder de kruin)\nupper_limit_coarse: float De bovengrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in grove stappen (standaard 2.0m onder de kruin). Er is geen lower_limit_fine omdat deze altijd gelijk is aan upper_limit_coarse.\nupper_limit_fine: float De bovengrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in fijne stappen (standaard 1.01m boven de kruin)\nhstap: float De fijne stapgrootte van de waterstanden waarvoor de fragiliteitscurve wordt berekend (standaard 0.05), de grove stapgrootte is 2 * hstap.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_bed_levels\n\n\n\ndf_out\n\n\n\ndf_slopes\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor golf overslag\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.FragilityCurveOvertopping.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.FragilityCurveOvertopping.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand. Parameters: input (list[str]): Een lijst met de bestandsnamen van de inputbestanden. output (str): De bestandsnaam waarin het resultaat moet worden opgeslagen. Returns: None\n\n\n\nfragility_curves.FragilityCurveOvertopping.load(input)\nLaad een fragility curve in\n\n\n\nfragility_curves.FragilityCurveOvertopping.refine(waterlevels)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.FragilityCurveOvertopping.run(input, output)\nRunt de berekening van de fragility curve voor golf overslag\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_slopes (pd.DataFrame), [1] df_profile (pd.DataFrame), [2] df_bed_levels (pd.DataFrame)\nrequired\n\n\noutput\nstr\nFragility curve output\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_slopes (pd.DataFrame)\n\n        DataFrame met helling data.\n        Moet de volgende kolommen bevatten:\n        - x : float\n        - y : float\n        - r : float\n        - slopetypeid : int (1: dike or 2: slope)\n\n   [1] df_profile (pd.DataFrame):\n        DataFrame met profiel data.\n        Moet de volgende kolommen bevatten:\n        - windspeed : float\n        - sectormin : float\n        - sectorsize : float\n        - orientation : float (in graden)\n        - crestlevel : float (in meters)\n        - dam : int (0: geen dam or 1: dam)\n        - damheight : float (in meters)\n        - qcr : float (waarde in m^3/s)\n            str (closed | open)\n            tuple (waarden van mu en sigma)\n\n   [2] df_bed_levels (pd.DataFrame):\n        DataFrame met bed level data.\n        Moet de volgende kolommen bevatten:\n        - direction : float\n        - bedlevel : float\n        - fetch : float\n\n\n\n\nfragility_curves.FragilityCurveOvertopping.shift(effect)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "reference/FragilityCurveOvertopping.html#options-in-config",
    "href": "reference/FragilityCurveOvertopping.html#options-in-config",
    "title": "FragilityCurveOvertopping",
    "section": "",
    "text": "Onzekerheden: float - gh_onz_mu GolfHoogte onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfhoogte (standaard 0.96)\n- gh_onz_sigma\n    GolfHoogte onzekerheid sigma: standaard afwijking waarde (standaard 0.27)\n\n- gp_onz_mu_tp\n    GolfPerioden onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfperiode (standaard 1.03)\n\n- gp_onz_sigma_tp\n    GolfPerioden onzekerheid sigma: standaard afwijking waarde (standaard 0.13)\n\n- gp_onz_mu_tspec\n    GolfPerioden onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfperiode (standaard 1.03)\n\n- gp_onz_sigma_tspec\n    GolfPerioden onzekerheid sigma: standaard afwijking waarde (standaard 0.13)\n\n- gh_onz_aantal\n    Aantal onzekerheden in de golfhoogte (standaard 7)\n- gp_onz_aantal\n    Aantal onzekerheden in de golfperiode (standaard 7)\ntp_tspec: float de verhouding tussen de piek periode van de golf ($T_p$) en de spectrale golfperiode ($Tm_{-1,0}$) (standaard 1.1).\nDe waterniveaus waarmee probablistisch gerekend wordt is verdeelt in twee delen: grof en fijn.\nlower_limit_coarse: float De ondergrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in grove stappen (standaard 4.0m onder de kruin)\nupper_limit_coarse: float De bovengrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in grove stappen (standaard 2.0m onder de kruin). Er is geen lower_limit_fine omdat deze altijd gelijk is aan upper_limit_coarse.\nupper_limit_fine: float De bovengrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in fijne stappen (standaard 1.01m boven de kruin)\nhstap: float De fijne stapgrootte van de waterstanden waarvoor de fragiliteitscurve wordt berekend (standaard 0.05), de grove stapgrootte is 2 * hstap."
  },
  {
    "objectID": "reference/FragilityCurveOvertopping.html#attributes",
    "href": "reference/FragilityCurveOvertopping.html#attributes",
    "title": "FragilityCurveOvertopping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_bed_levels\n\n\n\ndf_out\n\n\n\ndf_slopes\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary"
  },
  {
    "objectID": "reference/FragilityCurveOvertopping.html#methods",
    "href": "reference/FragilityCurveOvertopping.html#methods",
    "title": "FragilityCurveOvertopping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor golf overslag\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.FragilityCurveOvertopping.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.FragilityCurveOvertopping.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand. Parameters: input (list[str]): Een lijst met de bestandsnamen van de inputbestanden. output (str): De bestandsnaam waarin het resultaat moet worden opgeslagen. Returns: None\n\n\n\nfragility_curves.FragilityCurveOvertopping.load(input)\nLaad een fragility curve in\n\n\n\nfragility_curves.FragilityCurveOvertopping.refine(waterlevels)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.FragilityCurveOvertopping.run(input, output)\nRunt de berekening van de fragility curve voor golf overslag\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_slopes (pd.DataFrame), [1] df_profile (pd.DataFrame), [2] df_bed_levels (pd.DataFrame)\nrequired\n\n\noutput\nstr\nFragility curve output\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_slopes (pd.DataFrame)\n\n        DataFrame met helling data.\n        Moet de volgende kolommen bevatten:\n        - x : float\n        - y : float\n        - r : float\n        - slopetypeid : int (1: dike or 2: slope)\n\n   [1] df_profile (pd.DataFrame):\n        DataFrame met profiel data.\n        Moet de volgende kolommen bevatten:\n        - windspeed : float\n        - sectormin : float\n        - sectorsize : float\n        - orientation : float (in graden)\n        - crestlevel : float (in meters)\n        - dam : int (0: geen dam or 1: dam)\n        - damheight : float (in meters)\n        - qcr : float (waarde in m^3/s)\n            str (closed | open)\n            tuple (waarden van mu en sigma)\n\n   [2] df_bed_levels (pd.DataFrame):\n        DataFrame met bed level data.\n        Moet de volgende kolommen bevatten:\n        - direction : float\n        - bedlevel : float\n        - fetch : float\n\n\n\n\nfragility_curves.FragilityCurveOvertopping.shift(effect)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "reference/FragilityCurvesOvertopping.html",
    "href": "reference/FragilityCurvesOvertopping.html",
    "title": "FragilityCurvesOvertopping",
    "section": "",
    "text": "fragility_curves.FragilityCurvesOvertopping()\nMaakt een set van fragility curve voor golf overslag voor een dijkvak.\nArgs: data_adapter: DataAdapter DataAdapter object df_slopes: pd.DataFrame DataFrame met helling data. df_bed_levels: pd.DataFrame DataFrame met bed level data. df_out: pd.DataFrame DataFrame met de resultaten van de berekening. fragility_curve_function: FragilityCurve FragilityCurve object effect: float Effect van de maatregel (niet gebruikt) measure_id: int Maatregel id (niet gebruikt)\n\n\nOnzekerheden: float gh_onz_mu GolfHoogte onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfhoogte (standaard 0.96) gh_onz_sigma GolfHoogte onzekerheid sigma: standaard afwijking waarde (standaard 0.27) gp_onz_mu_tp GolfPerioden onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfperiode (standaard 1.03) gp_onz_sigma_tp GolfPerioden onzekerheid sigma: standaard afwijking waarde (standaard 0.13) gp_onz_mu_tspec GolfPerioden onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfperiode (standaard 1.03) gp_onz_sigma_tspec GolfPerioden onzekerheid sigma: standaard afwijking waarde (standaard 0.13) gh_onz_aantal Aantal onzekerheden in de golfhoogte (standaard 7) gp_onz_aantal Aantal onzekerheden in de golfperiode (standaard 7)\ntp_tspec: float de verhouding tussen de piek periode van de golf ($T_p$) en de spectrale golfperiode ($Tm_{-1,0}$) (standaard 1.1).\nDe waterniveaus waarmee probablistisch gerekend wordt is verdeelt in twee delen: grof en fijn.\nlower_limit_coarse: float De ondergrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in grove stappen (standaard 4.0m onder de kruin) upper_limit_coarse: float De bovengrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in grove stappen (standaard 2.0m onder de kruin). Er is geen lower_limit_fine omdat deze altijd gelijk is aan upper_limit_coarse. upper_limit_fine: float De bovengrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in fijne stappen (standaard 1.01m boven de kruin) hstap: float De fijne stapgrootte van de waterstanden waarvoor de fragiliteitscurve wordt berekend (standaard 0.05), de grove stapgrootte is 2 * hstap.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_bed_levels\n\n\n\ndf_out\n\n\n\ndf_slopes\n\n\n\neffect\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary\n\n\nmeasure_id\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfragility_curve_function\nMaakt een enkele fragility curve voor golf overslag.\n\n\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function()\nMaakt een enkele fragility curve voor golf overslag.\nArgs: data_adapter (DataAdapter): DataAdapter object\n\n\nOnzekerheden: float - gh_onz_mu GolfHoogte onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfhoogte (standaard 0.96)\n- gh_onz_sigma\n    GolfHoogte onzekerheid sigma: standaard afwijking waarde (standaard 0.27)\n\n- gp_onz_mu_tp\n    GolfPerioden onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfperiode (standaard 1.03)\n\n- gp_onz_sigma_tp\n    GolfPerioden onzekerheid sigma: standaard afwijking waarde (standaard 0.13)\n\n- gp_onz_mu_tspec\n    GolfPerioden onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfperiode (standaard 1.03)\n\n- gp_onz_sigma_tspec\n    GolfPerioden onzekerheid sigma: standaard afwijking waarde (standaard 0.13)\n\n- gh_onz_aantal\n    Aantal onzekerheden in de golfhoogte (standaard 7)\n- gp_onz_aantal\n    Aantal onzekerheden in de golfperiode (standaard 7)\ntp_tspec: float de verhouding tussen de piek periode van de golf ($T_p$) en de spectrale golfperiode ($Tm_{-1,0}$) (standaard 1.1).\nDe waterniveaus waarmee probablistisch gerekend wordt is verdeelt in twee delen: grof en fijn.\nlower_limit_coarse: float De ondergrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in grove stappen (standaard 4.0m onder de kruin)\nupper_limit_coarse: float De bovengrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in grove stappen (standaard 2.0m onder de kruin). Er is geen lower_limit_fine omdat deze altijd gelijk is aan upper_limit_coarse.\nupper_limit_fine: float De bovengrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in fijne stappen (standaard 1.01m boven de kruin)\nhstap: float De fijne stapgrootte van de waterstanden waarvoor de fragiliteitscurve wordt berekend (standaard 0.05), de grove stapgrootte is 2 * hstap.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_bed_levels\n\n\n\ndf_out\n\n\n\ndf_slopes\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor golf overslag\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand. Parameters: input (list[str]): Een lijst met de bestandsnamen van de inputbestanden. output (str): De bestandsnaam waarin het resultaat moet worden opgeslagen. Returns: None\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function.load(input)\nLaad een fragility curve in\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function.refine(\n    waterlevels\n)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function.run(\n    input\n    output\n)\nRunt de berekening van de fragility curve voor golf overslag\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_slopes (pd.DataFrame), [1] df_profile (pd.DataFrame), [2] df_bed_levels (pd.DataFrame)\nrequired\n\n\noutput\nstr\nFragility curve output\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_slopes (pd.DataFrame)\n\n        DataFrame met helling data.\n        Moet de volgende kolommen bevatten:\n        - x : float\n        - y : float\n        - r : float\n        - slopetypeid : int (1: dike or 2: slope)\n\n   [1] df_profile (pd.DataFrame):\n        DataFrame met profiel data.\n        Moet de volgende kolommen bevatten:\n        - windspeed : float\n        - sectormin : float\n        - sectorsize : float\n        - orientation : float (in graden)\n        - crestlevel : float (in meters)\n        - dam : int (0: geen dam or 1: dam)\n        - damheight : float (in meters)\n        - qcr : float (waarde in m^3/s)\n            str (closed | open)\n            tuple (waarden van mu en sigma)\n\n   [2] df_bed_levels (pd.DataFrame):\n        DataFrame met bed level data.\n        Moet de volgende kolommen bevatten:\n        - direction : float\n        - bedlevel : float\n        - fetch : float\n\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function.shift(\n    effect\n)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor golf overslag\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.FragilityCurvesOvertopping.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.FragilityCurvesOvertopping.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand. Parameters: input (list[str]): Een lijst met de bestandsnamen van de inputbestanden. output (str): De bestandsnaam waarin het resultaat moet worden opgeslagen. Returns: None\n\n\n\nfragility_curves.FragilityCurvesOvertopping.load(input)\nLaad een fragility curve in\n\n\n\nfragility_curves.FragilityCurvesOvertopping.refine(waterlevels)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.FragilityCurvesOvertopping.run(input, output)\nRunt de berekening van de fragility curve voor golf overslag\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_slopes (pd.DataFrame), [1] df_profile (pd.DataFrame), [2] df_bed_levels (pd.DataFrame)\nrequired\n\n\noutput\nstr\nFragility curve output\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_slopes (pd.DataFrame)\n\n        DataFrame met helling data.\n        Moet de volgende kolommen bevatten:\n        - section_id : int\n        - x : float\n        - y : float\n        - r : float\n        - slopetypeid : int (1: dike or 2: slope)\n\n   [1] df_profile (pd.DataFrame):\n        DataFrame met profiel data.\n        Moet de volgende kolommen bevatten:\n        - section_id : int\n        - windspeed : float\n        - sectormin : float\n        - sectorsize : float\n        - orientation : float (in graden)\n        - crestlevel : float (in meters)\n        - dam : int (0: geen dam or 1: dam)\n        - damheight : float (in meters)\n        - qcr : float (waarde in m^3/s)\n            str (close | open)\n            tuple (waarden van mu en sigma)\n\n   [2] df_bed_levels (pd.DataFrame):\n        DataFrame met bed level data.\n        Moet de volgende kolommen bevatten:\n        - section_id : int\n        - direction : float\n        - bedlevel : float\n        - fetch : float\n\n\n\n\nfragility_curves.FragilityCurvesOvertopping.shift(effect)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "reference/FragilityCurvesOvertopping.html#options-in-config",
    "href": "reference/FragilityCurvesOvertopping.html#options-in-config",
    "title": "FragilityCurvesOvertopping",
    "section": "",
    "text": "Onzekerheden: float gh_onz_mu GolfHoogte onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfhoogte (standaard 0.96) gh_onz_sigma GolfHoogte onzekerheid sigma: standaard afwijking waarde (standaard 0.27) gp_onz_mu_tp GolfPerioden onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfperiode (standaard 1.03) gp_onz_sigma_tp GolfPerioden onzekerheid sigma: standaard afwijking waarde (standaard 0.13) gp_onz_mu_tspec GolfPerioden onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfperiode (standaard 1.03) gp_onz_sigma_tspec GolfPerioden onzekerheid sigma: standaard afwijking waarde (standaard 0.13) gh_onz_aantal Aantal onzekerheden in de golfhoogte (standaard 7) gp_onz_aantal Aantal onzekerheden in de golfperiode (standaard 7)\ntp_tspec: float de verhouding tussen de piek periode van de golf ($T_p$) en de spectrale golfperiode ($Tm_{-1,0}$) (standaard 1.1).\nDe waterniveaus waarmee probablistisch gerekend wordt is verdeelt in twee delen: grof en fijn.\nlower_limit_coarse: float De ondergrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in grove stappen (standaard 4.0m onder de kruin) upper_limit_coarse: float De bovengrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in grove stappen (standaard 2.0m onder de kruin). Er is geen lower_limit_fine omdat deze altijd gelijk is aan upper_limit_coarse. upper_limit_fine: float De bovengrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in fijne stappen (standaard 1.01m boven de kruin) hstap: float De fijne stapgrootte van de waterstanden waarvoor de fragiliteitscurve wordt berekend (standaard 0.05), de grove stapgrootte is 2 * hstap."
  },
  {
    "objectID": "reference/FragilityCurvesOvertopping.html#attributes",
    "href": "reference/FragilityCurvesOvertopping.html#attributes",
    "title": "FragilityCurvesOvertopping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_bed_levels\n\n\n\ndf_out\n\n\n\ndf_slopes\n\n\n\neffect\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary\n\n\nmeasure_id"
  },
  {
    "objectID": "reference/FragilityCurvesOvertopping.html#classes",
    "href": "reference/FragilityCurvesOvertopping.html#classes",
    "title": "FragilityCurvesOvertopping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfragility_curve_function\nMaakt een enkele fragility curve voor golf overslag.\n\n\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function()\nMaakt een enkele fragility curve voor golf overslag.\nArgs: data_adapter (DataAdapter): DataAdapter object\n\n\nOnzekerheden: float - gh_onz_mu GolfHoogte onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfhoogte (standaard 0.96)\n- gh_onz_sigma\n    GolfHoogte onzekerheid sigma: standaard afwijking waarde (standaard 0.27)\n\n- gp_onz_mu_tp\n    GolfPerioden onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfperiode (standaard 1.03)\n\n- gp_onz_sigma_tp\n    GolfPerioden onzekerheid sigma: standaard afwijking waarde (standaard 0.13)\n\n- gp_onz_mu_tspec\n    GolfPerioden onzekerheid mu: gemiddelde waarde van de onzekerheid van de golfperiode (standaard 1.03)\n\n- gp_onz_sigma_tspec\n    GolfPerioden onzekerheid sigma: standaard afwijking waarde (standaard 0.13)\n\n- gh_onz_aantal\n    Aantal onzekerheden in de golfhoogte (standaard 7)\n- gp_onz_aantal\n    Aantal onzekerheden in de golfperiode (standaard 7)\ntp_tspec: float de verhouding tussen de piek periode van de golf ($T_p$) en de spectrale golfperiode ($Tm_{-1,0}$) (standaard 1.1).\nDe waterniveaus waarmee probablistisch gerekend wordt is verdeelt in twee delen: grof en fijn.\nlower_limit_coarse: float De ondergrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in grove stappen (standaard 4.0m onder de kruin)\nupper_limit_coarse: float De bovengrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in grove stappen (standaard 2.0m onder de kruin). Er is geen lower_limit_fine omdat deze altijd gelijk is aan upper_limit_coarse.\nupper_limit_fine: float De bovengrens van de waterstanden waarvoor de fragiliteitscurve wordt berekend in fijne stappen (standaard 1.01m boven de kruin)\nhstap: float De fijne stapgrootte van de waterstanden waarvoor de fragiliteitscurve wordt berekend (standaard 0.05), de grove stapgrootte is 2 * hstap.\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_bed_levels\n\n\n\ndf_out\n\n\n\ndf_slopes\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor golf overslag\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand. Parameters: input (list[str]): Een lijst met de bestandsnamen van de inputbestanden. output (str): De bestandsnaam waarin het resultaat moet worden opgeslagen. Returns: None\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function.load(input)\nLaad een fragility curve in\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function.refine(\n    waterlevels\n)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function.run(\n    input\n    output\n)\nRunt de berekening van de fragility curve voor golf overslag\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_slopes (pd.DataFrame), [1] df_profile (pd.DataFrame), [2] df_bed_levels (pd.DataFrame)\nrequired\n\n\noutput\nstr\nFragility curve output\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_slopes (pd.DataFrame)\n\n        DataFrame met helling data.\n        Moet de volgende kolommen bevatten:\n        - x : float\n        - y : float\n        - r : float\n        - slopetypeid : int (1: dike or 2: slope)\n\n   [1] df_profile (pd.DataFrame):\n        DataFrame met profiel data.\n        Moet de volgende kolommen bevatten:\n        - windspeed : float\n        - sectormin : float\n        - sectorsize : float\n        - orientation : float (in graden)\n        - crestlevel : float (in meters)\n        - dam : int (0: geen dam or 1: dam)\n        - damheight : float (in meters)\n        - qcr : float (waarde in m^3/s)\n            str (closed | open)\n            tuple (waarden van mu en sigma)\n\n   [2] df_bed_levels (pd.DataFrame):\n        DataFrame met bed level data.\n        Moet de volgende kolommen bevatten:\n        - direction : float\n        - bedlevel : float\n        - fetch : float\n\n\n\n\nfragility_curves.FragilityCurvesOvertopping.fragility_curve_function.shift(\n    effect\n)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "reference/FragilityCurvesOvertopping.html#methods-1",
    "href": "reference/FragilityCurvesOvertopping.html#methods-1",
    "title": "FragilityCurvesOvertopping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor golf overslag\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.FragilityCurvesOvertopping.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.FragilityCurvesOvertopping.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand. Parameters: input (list[str]): Een lijst met de bestandsnamen van de inputbestanden. output (str): De bestandsnaam waarin het resultaat moet worden opgeslagen. Returns: None\n\n\n\nfragility_curves.FragilityCurvesOvertopping.load(input)\nLaad een fragility curve in\n\n\n\nfragility_curves.FragilityCurvesOvertopping.refine(waterlevels)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.FragilityCurvesOvertopping.run(input, output)\nRunt de berekening van de fragility curve voor golf overslag\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_slopes (pd.DataFrame), [1] df_profile (pd.DataFrame), [2] df_bed_levels (pd.DataFrame)\nrequired\n\n\noutput\nstr\nFragility curve output\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_slopes (pd.DataFrame)\n\n        DataFrame met helling data.\n        Moet de volgende kolommen bevatten:\n        - section_id : int\n        - x : float\n        - y : float\n        - r : float\n        - slopetypeid : int (1: dike or 2: slope)\n\n   [1] df_profile (pd.DataFrame):\n        DataFrame met profiel data.\n        Moet de volgende kolommen bevatten:\n        - section_id : int\n        - windspeed : float\n        - sectormin : float\n        - sectorsize : float\n        - orientation : float (in graden)\n        - crestlevel : float (in meters)\n        - dam : int (0: geen dam or 1: dam)\n        - damheight : float (in meters)\n        - qcr : float (waarde in m^3/s)\n            str (close | open)\n            tuple (waarden van mu en sigma)\n\n   [2] df_bed_levels (pd.DataFrame):\n        DataFrame met bed level data.\n        Moet de volgende kolommen bevatten:\n        - section_id : int\n        - direction : float\n        - bedlevel : float\n        - fetch : float\n\n\n\n\nfragility_curves.FragilityCurvesOvertopping.shift(effect)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "reference/get_fews_locations.html",
    "href": "reference/get_fews_locations.html",
    "title": "get_fews_locations",
    "section": "",
    "text": "get_fews_locations\nloads.get_fews_locations(host, port, region, filter_id)\nHaal voor Fews de locaties op voor de opgegegeven parameters.\nArgs: host (str): Fews server host url port (int): port waar de rest service draait region (str): in fews gedefinieerde region filter_id (str): filter van de locaties\nReturns: Dataframe: Pandas dataframe met locaties"
  },
  {
    "objectID": "reference/get_matroos_locations.html",
    "href": "reference/get_matroos_locations.html",
    "title": "get_matroos_locations",
    "section": "",
    "text": "get_matroos_locations\nloads.get_matroos_locations(source=None, parameter=None)\nHaal alle matroos locaties op, indien gewenst ook bron en parameter."
  },
  {
    "objectID": "reference/get_waterinfo_locations.html",
    "href": "reference/get_waterinfo_locations.html",
    "title": "get_waterinfo_locations",
    "section": "",
    "text": "get_waterinfo_locations\nloads.get_waterinfo_locations(parameter_id='waterhoogte')\nHaal voor Waterinfo de locaties op voor de opgegegeven parameter.\nArgs: parameter_id (str): Waterinfo parameter bij geen waarde ‘waterhoogte’\nReturns: Dataframe: Pandas dataframe met locaties"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "Basis functionaliteit waar andere functies op verder bouwen\n\n\n\nConfig\nBasis functie om de configuratie in te laden.\n\n\nDataAdapter\nBasis DataAdapter\n\n\nproof_of_concept.example_module\n\n\n\nFragilityCurve\nClass met een aantal gemakkelijke methoden om fragility curves\n\n\n\n\n\n\nFuncties die belastingen inladen, classificeren of toekennen.\n\n\n\nLoadsCIWhatIf\nMet deze functie worden belasting opgehaald en weggeschreven.\n\n\nLoadsClassify\nMet deze functie worden de waterstanden met opgegeven grenzen geclassificeerd.\n\n\nLoadsFews\nMet deze functie worden gegevens uit de opgegeven FEWS omgeving opgehaald via REST.\n\n\nget_fews_locations\nHaal voor Fews de locaties op voor de opgegegeven parameters.\n\n\nget_fews_thresholds\nHaal voor Fews de thresholds op voor de opgegegeven parameter en locatie.\n\n\nLoadsMatroos\nDe LoadsMatroos klasse haalt belastinggegevens op van de Rijkswaterstaat Waterwebservices.\n\n\nget_matroos_locations\nHaal alle matroos locaties op, indien gewenst ook bron en parameter.\n\n\nLoadsWaterwebservicesRWS\nBelastinggegevens ophalen van rijkswaterstaat waterwebservices https://waterwebservices.rijkswaterstaat.nl/\n\n\nget_rws_webservices_locations\nHaal locaties op die bekend zijn bij de RWS webservice.\n\n\nLoadsToMoments\nMet deze klasse kunnen waterstandsgegevens worden omgezet naar bepaalde momenten.\n\n\nLoadsWaterinfo\nBelastinggegevens ophalen van rijkswaterstaat Waterinfo https://waterinfo.rws.nl/#/publiek/waterhoogte\n\n\nget_waterinfo_locations\nHaal voor Waterinfo de locaties op voor de opgegegeven parameter.\n\n\nget_waterinfo_thresholds\nHaal voor Waterinfo de thresholds op voor de opgegegeven parameter.\n\n\n\n\n\n\nFuncties die betrekking hebben op dijkvakken\n\n\n\nSectionsLoads\nBepaal de belasting op een dijkvak\n\n\nSectionsFailureprobability\nBepaal de faalkans van een dijkvak\n\n\nSectionsTechnicalFailureprobability\nBepaal de technische faalkans van een dijkvak\n\n\nSectionsMeasureFailureprobability\nBepaal de faalkans door een maatregel van een dijkvak\n\n\nSectionsClassify\nBepaal de status van een dijkvak\n\n\n\n\n\n\nFuncties voor het berekenen en aanpassen van Fragility curve\n\n\n\nFragilityCurveOvertopping\nMaakt een enkele fragility curve voor golf overslag.\n\n\nFragilityCurvesOvertopping\nMaakt een set van fragility curve voor golf overslag voor een dijkvak.\n\n\nShiftFragilityCurveOvertopping\nVerschuift de fragility curve met een gegeven effect\n\n\nChangeCrestHeightFragilityCurveOvertopping\nVerschuift de kruin hoogte met het gegeven effect en berekent de fragility curve\n\n\nFragilityCurvePipingFixedWaterlevelSimple\nMaakt een enkele fragility curve voor piping met een gegeven waterstand.\n\n\nFragilityCurvesPiping\nMaakt een set van fragility curves voor piping voor een dijkvak.\n\n\nCombineFragilityCurvesIndependent\nCombineer meerdere fragility curves onafhankelijk tot een enkele fragility curves.\n\n\nCombineFragilityCurvesDependent\nCombineer meerdere fragility curves afhankelijk tot een enkele fragility curves.\n\n\nCombineFragilityCurvesWeightedSum\nCombineer meerdere fragility curves met een gewogen som tot een enkele fragility curves.\n\n\n\n\n\n\nInvoer adapters voor Continu Inzicht meetstations/ dijkvak\n\n\n\ninput_measuringstation\nData adapters voor het lezen van data uit de Continu Inzicht database\n\n\ninput_section\nData adapters voor het lezen van data uit de Continu Inzicht database\n\n\ninput_fragilitycurve\nData adapters voor het lezen van data uit de Continu Inzicht database\n\n\n\n\n\n\nUitvoer adapters voor Continu Inzicht meetstations/ dijkvak\n\n\n\noutput_measuringstation\nData adapters voor het schrijven naar de Continu Inzicht database\n\n\noutput_section\nData adapters voor het schrijven naar de Continu Inzicht database\n\n\noutput_calculation\nData adapters voor het schrijven naar de Continu Inzicht database",
    "crumbs": [
      "Python API",
      "API Reference"
    ]
  },
  {
    "objectID": "reference/index.html#basis",
    "href": "reference/index.html#basis",
    "title": "API Reference",
    "section": "",
    "text": "Basis functionaliteit waar andere functies op verder bouwen\n\n\n\nConfig\nBasis functie om de configuratie in te laden.\n\n\nDataAdapter\nBasis DataAdapter\n\n\nproof_of_concept.example_module\n\n\n\nFragilityCurve\nClass met een aantal gemakkelijke methoden om fragility curves",
    "crumbs": [
      "Python API",
      "API Reference"
    ]
  },
  {
    "objectID": "reference/index.html#belastingen",
    "href": "reference/index.html#belastingen",
    "title": "API Reference",
    "section": "",
    "text": "Functies die belastingen inladen, classificeren of toekennen.\n\n\n\nLoadsCIWhatIf\nMet deze functie worden belasting opgehaald en weggeschreven.\n\n\nLoadsClassify\nMet deze functie worden de waterstanden met opgegeven grenzen geclassificeerd.\n\n\nLoadsFews\nMet deze functie worden gegevens uit de opgegeven FEWS omgeving opgehaald via REST.\n\n\nget_fews_locations\nHaal voor Fews de locaties op voor de opgegegeven parameters.\n\n\nget_fews_thresholds\nHaal voor Fews de thresholds op voor de opgegegeven parameter en locatie.\n\n\nLoadsMatroos\nDe LoadsMatroos klasse haalt belastinggegevens op van de Rijkswaterstaat Waterwebservices.\n\n\nget_matroos_locations\nHaal alle matroos locaties op, indien gewenst ook bron en parameter.\n\n\nLoadsWaterwebservicesRWS\nBelastinggegevens ophalen van rijkswaterstaat waterwebservices https://waterwebservices.rijkswaterstaat.nl/\n\n\nget_rws_webservices_locations\nHaal locaties op die bekend zijn bij de RWS webservice.\n\n\nLoadsToMoments\nMet deze klasse kunnen waterstandsgegevens worden omgezet naar bepaalde momenten.\n\n\nLoadsWaterinfo\nBelastinggegevens ophalen van rijkswaterstaat Waterinfo https://waterinfo.rws.nl/#/publiek/waterhoogte\n\n\nget_waterinfo_locations\nHaal voor Waterinfo de locaties op voor de opgegegeven parameter.\n\n\nget_waterinfo_thresholds\nHaal voor Waterinfo de thresholds op voor de opgegegeven parameter.",
    "crumbs": [
      "Python API",
      "API Reference"
    ]
  },
  {
    "objectID": "reference/index.html#dijkvak",
    "href": "reference/index.html#dijkvak",
    "title": "API Reference",
    "section": "",
    "text": "Functies die betrekking hebben op dijkvakken\n\n\n\nSectionsLoads\nBepaal de belasting op een dijkvak\n\n\nSectionsFailureprobability\nBepaal de faalkans van een dijkvak\n\n\nSectionsTechnicalFailureprobability\nBepaal de technische faalkans van een dijkvak\n\n\nSectionsMeasureFailureprobability\nBepaal de faalkans door een maatregel van een dijkvak\n\n\nSectionsClassify\nBepaal de status van een dijkvak",
    "crumbs": [
      "Python API",
      "API Reference"
    ]
  },
  {
    "objectID": "reference/index.html#fragility-curves",
    "href": "reference/index.html#fragility-curves",
    "title": "API Reference",
    "section": "",
    "text": "Functies voor het berekenen en aanpassen van Fragility curve\n\n\n\nFragilityCurveOvertopping\nMaakt een enkele fragility curve voor golf overslag.\n\n\nFragilityCurvesOvertopping\nMaakt een set van fragility curve voor golf overslag voor een dijkvak.\n\n\nShiftFragilityCurveOvertopping\nVerschuift de fragility curve met een gegeven effect\n\n\nChangeCrestHeightFragilityCurveOvertopping\nVerschuift de kruin hoogte met het gegeven effect en berekent de fragility curve\n\n\nFragilityCurvePipingFixedWaterlevelSimple\nMaakt een enkele fragility curve voor piping met een gegeven waterstand.\n\n\nFragilityCurvesPiping\nMaakt een set van fragility curves voor piping voor een dijkvak.\n\n\nCombineFragilityCurvesIndependent\nCombineer meerdere fragility curves onafhankelijk tot een enkele fragility curves.\n\n\nCombineFragilityCurvesDependent\nCombineer meerdere fragility curves afhankelijk tot een enkele fragility curves.\n\n\nCombineFragilityCurvesWeightedSum\nCombineer meerdere fragility curves met een gewogen som tot een enkele fragility curves.",
    "crumbs": [
      "Python API",
      "API Reference"
    ]
  },
  {
    "objectID": "reference/index.html#continu-inzicht-adapters-invoer",
    "href": "reference/index.html#continu-inzicht-adapters-invoer",
    "title": "API Reference",
    "section": "",
    "text": "Invoer adapters voor Continu Inzicht meetstations/ dijkvak\n\n\n\ninput_measuringstation\nData adapters voor het lezen van data uit de Continu Inzicht database\n\n\ninput_section\nData adapters voor het lezen van data uit de Continu Inzicht database\n\n\ninput_fragilitycurve\nData adapters voor het lezen van data uit de Continu Inzicht database",
    "crumbs": [
      "Python API",
      "API Reference"
    ]
  },
  {
    "objectID": "reference/index.html#continu-inzicht-adapters-uitvoer",
    "href": "reference/index.html#continu-inzicht-adapters-uitvoer",
    "title": "API Reference",
    "section": "",
    "text": "Uitvoer adapters voor Continu Inzicht meetstations/ dijkvak\n\n\n\noutput_measuringstation\nData adapters voor het schrijven naar de Continu Inzicht database\n\n\noutput_section\nData adapters voor het schrijven naar de Continu Inzicht database\n\n\noutput_calculation\nData adapters voor het schrijven naar de Continu Inzicht database",
    "crumbs": [
      "Python API",
      "API Reference"
    ]
  },
  {
    "objectID": "reference/input_measuringstation.html",
    "href": "reference/input_measuringstation.html",
    "title": "input_measuringstation",
    "section": "",
    "text": "base.adapters.input.continu_inzicht_postgresql.input_measuringstation\nData adapters voor het lezen van data uit de Continu Inzicht database\n\n\n\n\n\nName\nDescription\n\n\n\n\ninput_ci_postgresql_from_conditions\nOphalen klassegrenzen uit een Continu Inzicht database.\n\n\ninput_ci_postgresql_from_measuringstations\nOphalen meetstations uit een continu database.\n\n\ninput_ci_postgresql_from_waterlevels\nOphalen belasting uit een Continu Inzicht database voor het WhatIf scenario (tabel: waterstanden).\n\n\ninput_ci_postgresql_measuringstation_data_table\nOphalen tijdreeks van belasting per meetstation uit een Continu Inzicht database.\n\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_measuringstation.input_ci_postgresql_from_conditions(\n    input_config\n)\nOphalen klassegrenzen uit een Continu Inzicht database.\nYaml example:\ntype: ci_postgresql_from_conditions\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nmeasurement_location_id: int64 : id van het meetstation\nmeasurement_location_code: str : code van het meetstation\nlower_boundary: float64 : ondergrens van de klassegrens\nupper_boundary: float64 : bovengrens van de klassegrens\ncolor: str : kleur van de klassegrens\nlabel: str : legendanaam van de klassegrens\nunit: str : unit van de klassegrens\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_measuringstation.input_ci_postgresql_from_measuringstations(\n    input_config\n)\nOphalen meetstations uit een continu database.\nYaml example:\ntype: ci_postgresql_from_measuringstations\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nsource: \"waterinfo\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\nsource (str): source (veld) waar de meetstation aan gekoppeld zijn.\n\nReturns:\ndf (DataFrame):\n\nmeasurement_location_id: int64 : id van het meetstation\nmeasurement_location_code: str : code van het meetstation\nmeasurement_location_description: str : naam van het meetstation\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_measuringstation.input_ci_postgresql_from_waterlevels(\n    input_config\n)\nOphalen belasting uit een Continu Inzicht database voor het WhatIf scenario (tabel: waterstanden).\nYaml example:\ntype: ci_postgresql_from_waterlevels\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nmeasurement_location_id: int64 : id van het meetstation\nmeasurement_location_code: str : code van het meetstation\nmeasurement_location_description: str : naam van het meetstation\nparameter_id: int64 : id van de parameter\nparameter_code: str : code van de parameter\nparameter_description: str : omschrijving van de parameter\nunit: str : unit van de parameter\ndate_time: datetime64 : datum/ tijd van de tijdreeksitem\nvalue: float64 : waarde van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_measuringstation.input_ci_postgresql_measuringstation_data_table(\n    input_config\n)\nOphalen tijdreeks van belasting per meetstation uit een Continu Inzicht database.\nYaml example:\ntype: ci_postgresql_measuringstation_data_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nmeasurement_location_id: int64 : id van het meetstation\nmeasurement_location_code: str : code van het meetstation\nmeasurement_location_description: str : naam van het meetstation\nparameter_id: int64 : id van de parameter\nparameter_code: str : code van de parameter\nparameter_description: str : omschrijving van de parameter\nunit: str : unit van de parameter\ndate_time: datetime64 : datum/ tijd van de tijdreeksitem\nvalue: float64 : waarde van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)"
  },
  {
    "objectID": "reference/input_measuringstation.html#functions",
    "href": "reference/input_measuringstation.html#functions",
    "title": "input_measuringstation",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ninput_ci_postgresql_from_conditions\nOphalen klassegrenzen uit een Continu Inzicht database.\n\n\ninput_ci_postgresql_from_measuringstations\nOphalen meetstations uit een continu database.\n\n\ninput_ci_postgresql_from_waterlevels\nOphalen belasting uit een Continu Inzicht database voor het WhatIf scenario (tabel: waterstanden).\n\n\ninput_ci_postgresql_measuringstation_data_table\nOphalen tijdreeks van belasting per meetstation uit een Continu Inzicht database.\n\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_measuringstation.input_ci_postgresql_from_conditions(\n    input_config\n)\nOphalen klassegrenzen uit een Continu Inzicht database.\nYaml example:\ntype: ci_postgresql_from_conditions\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nmeasurement_location_id: int64 : id van het meetstation\nmeasurement_location_code: str : code van het meetstation\nlower_boundary: float64 : ondergrens van de klassegrens\nupper_boundary: float64 : bovengrens van de klassegrens\ncolor: str : kleur van de klassegrens\nlabel: str : legendanaam van de klassegrens\nunit: str : unit van de klassegrens\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_measuringstation.input_ci_postgresql_from_measuringstations(\n    input_config\n)\nOphalen meetstations uit een continu database.\nYaml example:\ntype: ci_postgresql_from_measuringstations\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nsource: \"waterinfo\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\nsource (str): source (veld) waar de meetstation aan gekoppeld zijn.\n\nReturns:\ndf (DataFrame):\n\nmeasurement_location_id: int64 : id van het meetstation\nmeasurement_location_code: str : code van het meetstation\nmeasurement_location_description: str : naam van het meetstation\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_measuringstation.input_ci_postgresql_from_waterlevels(\n    input_config\n)\nOphalen belasting uit een Continu Inzicht database voor het WhatIf scenario (tabel: waterstanden).\nYaml example:\ntype: ci_postgresql_from_waterlevels\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nmeasurement_location_id: int64 : id van het meetstation\nmeasurement_location_code: str : code van het meetstation\nmeasurement_location_description: str : naam van het meetstation\nparameter_id: int64 : id van de parameter\nparameter_code: str : code van de parameter\nparameter_description: str : omschrijving van de parameter\nunit: str : unit van de parameter\ndate_time: datetime64 : datum/ tijd van de tijdreeksitem\nvalue: float64 : waarde van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\n\n\n\n\nbase.adapters.input.continu_inzicht_postgresql.input_measuringstation.input_ci_postgresql_measuringstation_data_table(\n    input_config\n)\nOphalen tijdreeks van belasting per meetstation uit een Continu Inzicht database.\nYaml example:\ntype: ci_postgresql_measuringstation_data_table\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\ninput_config (dict): configuratie opties\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\nReturns:\ndf (DataFrame):\n\nmeasurement_location_id: int64 : id van het meetstation\nmeasurement_location_code: str : code van het meetstation\nmeasurement_location_description: str : naam van het meetstation\nparameter_id: int64 : id van de parameter\nparameter_code: str : code van de parameter\nparameter_description: str : omschrijving van de parameter\nunit: str : unit van de parameter\ndate_time: datetime64 : datum/ tijd van de tijdreeksitem\nvalue: float64 : waarde van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)"
  },
  {
    "objectID": "reference/LoadsCIWhatIf.html",
    "href": "reference/LoadsCIWhatIf.html",
    "title": "LoadsCIWhatIf",
    "section": "",
    "text": "loads.LoadsCIWhatIf()\nMet deze functie worden belasting opgehaald en weggeschreven.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun\nDe runner van de Loads Classify.\n\n\n\n\n\nloads.LoadsCIWhatIf.run(input, output)\nDe runner van de Loads Classify.\nArgs: input (str):\noutput (str):\nReturns: Dataframe: Pandas dataframe met …"
  },
  {
    "objectID": "reference/LoadsCIWhatIf.html#attributes",
    "href": "reference/LoadsCIWhatIf.html#attributes",
    "title": "LoadsCIWhatIf",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out"
  },
  {
    "objectID": "reference/LoadsCIWhatIf.html#methods",
    "href": "reference/LoadsCIWhatIf.html#methods",
    "title": "LoadsCIWhatIf",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrun\nDe runner van de Loads Classify.\n\n\n\n\n\nloads.LoadsCIWhatIf.run(input, output)\nDe runner van de Loads Classify.\nArgs: input (str):\noutput (str):\nReturns: Dataframe: Pandas dataframe met …"
  },
  {
    "objectID": "reference/LoadsFews.html",
    "href": "reference/LoadsFews.html",
    "title": "LoadsFews",
    "section": "",
    "text": "loads.LoadsFews()\nMet deze functie worden gegevens uit de opgegeven FEWS omgeving opgehaald via REST.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out\n\n\n\ninput_schema\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate_dataframe\nMaak een pandas dataframe\n\n\ncreate_params\nMaak een lijst van FEWS parameters om mee te sturen bij het ophalen van data.\n\n\ncreate_url\nMaak een rest url voor FEWS\n\n\nrun\nDe runner van de Loads Fews.\n\n\n\n\n\nloads.LoadsFews.create_dataframe(options, calc_time, json_data, locations)\nMaak een pandas dataframe\nArgs: json_data (str): JSON data\nReturns: Dataframe: Pandas dataframe geschikt voor uitvoer definition: - Meetlocatie id (measurement_location_id) - Meetlocatie code (measurement_location_code) - Meetlocatie omschrijving/naam (measurement_location_description) - Parameter id overeenkomstig Aquo-standaard: ‘4724’ (parameter_id) - Parameter code overeenkomstig Aquo-standaard: ‘WATHTE’ (parameter_code) - Parameter omschrijving overeenkomstig Aquo-standaard: ‘Waterhoogte’ (parameter_description) - Eenheid (unit) - Datum en tijd (date_time) - Waarde (value) - Type waarde: meting of verwachting (value_type)\n\n\n\nloads.LoadsFews.create_params(calc_time, options, moments, locations)\nMaak een lijst van FEWS parameters om mee te sturen bij het ophalen van data.\nArgs: calc_time (datetime): T0 in UTC options (type): options uit de invoer yaml\nReturns: dict: lijst met parameters\n\n\n\nloads.LoadsFews.create_url(options)\nMaak een rest url voor FEWS\nArgs: options (type): Options uit de invoer yaml\nReturns: str: URL\n\n\n\nloads.LoadsFews.run(input, output)\nDe runner van de Loads Fews.\nArgs:\nReturns: None"
  },
  {
    "objectID": "reference/LoadsFews.html#attributes",
    "href": "reference/LoadsFews.html#attributes",
    "title": "LoadsFews",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out\n\n\n\ninput_schema\ndict() -&gt; new empty dictionary"
  },
  {
    "objectID": "reference/LoadsFews.html#methods",
    "href": "reference/LoadsFews.html#methods",
    "title": "LoadsFews",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncreate_dataframe\nMaak een pandas dataframe\n\n\ncreate_params\nMaak een lijst van FEWS parameters om mee te sturen bij het ophalen van data.\n\n\ncreate_url\nMaak een rest url voor FEWS\n\n\nrun\nDe runner van de Loads Fews.\n\n\n\n\n\nloads.LoadsFews.create_dataframe(options, calc_time, json_data, locations)\nMaak een pandas dataframe\nArgs: json_data (str): JSON data\nReturns: Dataframe: Pandas dataframe geschikt voor uitvoer definition: - Meetlocatie id (measurement_location_id) - Meetlocatie code (measurement_location_code) - Meetlocatie omschrijving/naam (measurement_location_description) - Parameter id overeenkomstig Aquo-standaard: ‘4724’ (parameter_id) - Parameter code overeenkomstig Aquo-standaard: ‘WATHTE’ (parameter_code) - Parameter omschrijving overeenkomstig Aquo-standaard: ‘Waterhoogte’ (parameter_description) - Eenheid (unit) - Datum en tijd (date_time) - Waarde (value) - Type waarde: meting of verwachting (value_type)\n\n\n\nloads.LoadsFews.create_params(calc_time, options, moments, locations)\nMaak een lijst van FEWS parameters om mee te sturen bij het ophalen van data.\nArgs: calc_time (datetime): T0 in UTC options (type): options uit de invoer yaml\nReturns: dict: lijst met parameters\n\n\n\nloads.LoadsFews.create_url(options)\nMaak een rest url voor FEWS\nArgs: options (type): Options uit de invoer yaml\nReturns: str: URL\n\n\n\nloads.LoadsFews.run(input, output)\nDe runner van de Loads Fews.\nArgs:\nReturns: None"
  },
  {
    "objectID": "reference/LoadsToMoments.html",
    "href": "reference/LoadsToMoments.html",
    "title": "LoadsToMoments",
    "section": "",
    "text": "loads.LoadsToMoments()\nMet deze klasse kunnen waterstandsgegevens worden omgezet naar bepaalde momenten. Deze klasse bevat een methode genaamd ‘run’ die de waterstandsgegevens verwerkt en de resulterende momenten opslaat in een dataframe.\nAttributes: data_adapter (DataAdapter): Een object van de klasse DataAdapter. df_in (Optional[pd.DataFrame] | None): Het invoerdataframe met waterstandsgegevens. Standaard is dit None. df_out (Optional[pd.DataFrame] | None): Het uitvoerdataframe met de resulterende momenten. Standaard is dit None. Methods: run(input: str, output: str): Verwerkt de waterstandsgegevens en slaat de resulterende momenten op in het uitvoerdataframe. get_moment_from_dataframe(moment, df_moments): Haalt het moment op uit het gegeven dataframe met waterstandsgegevens.\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_moment_from_dataframe\nHaalt het moment op uit een dataframe van momenten.\n\n\nrun\nVerwerkt de invoergegevens om momenten te berekenen en genereert het uitvoerdataframe.\n\n\n\n\n\nloads.LoadsToMoments.get_moment_from_dataframe(moment, df_moments)\nHaalt het moment op uit een dataframe van momenten. Parameters: - moment: Het moment dat moet worden opgehaald. - df_moments: Het dataframe van momenten. Returns: Het dataframe met het opgehaalde moment.\n\n\n\nloads.LoadsToMoments.run(input, output)\nVerwerkt de invoergegevens om momenten te berekenen en genereert het uitvoerdataframe.\nArgs: input (str): Naam van de dataadapter met invoergegevens. output (str): Naam van de dataadapter om uitvoergegevens op te slaan. Returns: None"
  },
  {
    "objectID": "reference/LoadsToMoments.html#attributes",
    "href": "reference/LoadsToMoments.html#attributes",
    "title": "LoadsToMoments",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out"
  },
  {
    "objectID": "reference/LoadsToMoments.html#methods",
    "href": "reference/LoadsToMoments.html#methods",
    "title": "LoadsToMoments",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_moment_from_dataframe\nHaalt het moment op uit een dataframe van momenten.\n\n\nrun\nVerwerkt de invoergegevens om momenten te berekenen en genereert het uitvoerdataframe.\n\n\n\n\n\nloads.LoadsToMoments.get_moment_from_dataframe(moment, df_moments)\nHaalt het moment op uit een dataframe van momenten. Parameters: - moment: Het moment dat moet worden opgehaald. - df_moments: Het dataframe van momenten. Returns: Het dataframe met het opgehaalde moment.\n\n\n\nloads.LoadsToMoments.run(input, output)\nVerwerkt de invoergegevens om momenten te berekenen en genereert het uitvoerdataframe.\nArgs: input (str): Naam van de dataadapter met invoergegevens. output (str): Naam van de dataadapter om uitvoergegevens op te slaan. Returns: None"
  },
  {
    "objectID": "reference/LoadsWaterwebservicesRWS.html",
    "href": "reference/LoadsWaterwebservicesRWS.html",
    "title": "LoadsWaterwebservicesRWS",
    "section": "",
    "text": "loads.LoadsWaterwebservicesRWS()\nBelastinggegevens ophalen van rijkswaterstaat waterwebservices https://waterwebservices.rijkswaterstaat.nl/\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndata_adapter\nDataAdapter\nDe data adapter voor het ophalen en opslaan van gegevens. df_in: Optional[pd.DataFrame] | None = None Het invoerdataframe. df_out: Optional[pd.DataFrame] | None = None Het uitvoerdataframe.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate_dataframe\nMaakt een dataframe met waardes van de rws water webservices\n\n\ncreate_json_list\nMaak een lijst van FEWS parameters om mee te sturen bij het ophalen van data.\n\n\nrun\nDe runner van de Belasting WaterwebservicesRWS.\n\n\n\n\n\nloads.LoadsWaterwebservicesRWS.create_dataframe(\n    options\n    calc_time\n    lst_data\n    df_in\n)\nMaakt een dataframe met waardes van de rws water webservices\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noptions\ndict\nEen dictionary met opties uit de config\nrequired\n\n\ncalc_time\ndatetime\nDe huidige tijd\nrequired\n\n\nlst_data\nlist\nEen lijst met JSON data uit de post request\nrequired\n\n\n\n\n\n\npd.Dataframe\n    Pandas dataframe geschikt voor uitvoer\n\n\n\n\nloads.LoadsWaterwebservicesRWS.create_json_list(\n    measurement\n    calc_time\n    global_variables\n    locations\n)\nMaak een lijst van FEWS parameters om mee te sturen bij het ophalen van data.\nArgs: calc_time: T0 in UTC global_variables: globale variable uit de invoer yaml locations: dataframe with locations wanted\nReturns: dict: lijst met parameters\n\n\n\nloads.LoadsWaterwebservicesRWS.run(input, output)\nDe runner van de Belasting WaterwebservicesRWS."
  },
  {
    "objectID": "reference/LoadsWaterwebservicesRWS.html#attributes",
    "href": "reference/LoadsWaterwebservicesRWS.html#attributes",
    "title": "LoadsWaterwebservicesRWS",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ndata_adapter\nDataAdapter\nDe data adapter voor het ophalen en opslaan van gegevens. df_in: Optional[pd.DataFrame] | None = None Het invoerdataframe. df_out: Optional[pd.DataFrame] | None = None Het uitvoerdataframe."
  },
  {
    "objectID": "reference/LoadsWaterwebservicesRWS.html#methods",
    "href": "reference/LoadsWaterwebservicesRWS.html#methods",
    "title": "LoadsWaterwebservicesRWS",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncreate_dataframe\nMaakt een dataframe met waardes van de rws water webservices\n\n\ncreate_json_list\nMaak een lijst van FEWS parameters om mee te sturen bij het ophalen van data.\n\n\nrun\nDe runner van de Belasting WaterwebservicesRWS.\n\n\n\n\n\nloads.LoadsWaterwebservicesRWS.create_dataframe(\n    options\n    calc_time\n    lst_data\n    df_in\n)\nMaakt een dataframe met waardes van de rws water webservices\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noptions\ndict\nEen dictionary met opties uit de config\nrequired\n\n\ncalc_time\ndatetime\nDe huidige tijd\nrequired\n\n\nlst_data\nlist\nEen lijst met JSON data uit de post request\nrequired\n\n\n\n\n\n\npd.Dataframe\n    Pandas dataframe geschikt voor uitvoer\n\n\n\n\nloads.LoadsWaterwebservicesRWS.create_json_list(\n    measurement\n    calc_time\n    global_variables\n    locations\n)\nMaak een lijst van FEWS parameters om mee te sturen bij het ophalen van data.\nArgs: calc_time: T0 in UTC global_variables: globale variable uit de invoer yaml locations: dataframe with locations wanted\nReturns: dict: lijst met parameters\n\n\n\nloads.LoadsWaterwebservicesRWS.run(input, output)\nDe runner van de Belasting WaterwebservicesRWS."
  },
  {
    "objectID": "reference/output_measuringstation.html",
    "href": "reference/output_measuringstation.html",
    "title": "output_measuringstation",
    "section": "",
    "text": "base.adapters.output.continu_inzicht_postgresql.output_measuringstation\nData adapters voor het schrijven naar de Continu Inzicht database\n\n\n\n\n\nName\nDescription\n\n\n\n\noutput_ci_postgresql_conditions\nSchrijft voor condities van belastingen voor meetstations naar de Continu Inzicht database (tabel: conditions).\n\n\noutput_ci_postgresql_measuringstation\nSchrijft voor meetstations de classificatie data naar de Continu Inzicht database (tabel: states).\n\n\noutput_ci_postgresql_measuringstation_to_data\nSchrijft voor meetstations de belasting data naar de Continu Inzicht database (tabel: data).\n\n\noutput_ci_postgresql_to_moments\nSchrijft moments naar Continu Inzicht database (tabel: moments)\n\n\noutput_ci_postgresql_to_states\nSchrijft voor meetstations de classificatie data naar de Continu Inzicht database (tabel: states).\n\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_measuringstation.output_ci_postgresql_conditions(\n    output_config\n    df\n)\nSchrijft voor condities van belastingen voor meetstations naar de Continu Inzicht database (tabel: conditions).\nYaml example:\ntype: ci_postgresql_conditions\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_whatif\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- id: int64                 : id van de conditie\n- stateid: int64            : id van de status van een conditie\n- objectid: int64           : id van het object waartoe de conditie behoort (altijd in combinatie met objecttype)\n- objecttype: str           : het type object waartoe de conditie behoort (bijv. een 'section' of 'measuringstation')\n- upperboundary: float64    : de bovengrenswaarde van de status van een conditie (overgang van de betreffende status naar de volgende status)\n- name: str                 : naam van de status van de conditie\n- description: str          : omschrijving van de status van de conditie\n- color: str                : HEX kleurcode van de kleur van de status van de conditie\n- statevalue: float64       : middenwaarde van statusovergangen (specifiek voor objecttype 'sections')\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_measuringstation.output_ci_postgresql_measuringstation(\n    output_config\n    df\n)\nSchrijft voor meetstations de classificatie data naar de Continu Inzicht database (tabel: states).\nYaml example:\ntype: ci_postgresql_measuringstation\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_whatif\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- id: int64                 : id van het meetstation\n- name: str                 : naam van het meetstation\n- code: str                 : code van het meetstation\n- source: str               : bron van de data van het meetstation\n- geometry: geom            : geometrie (ligging) van het meetstation (let op projectie!)\n- tide: bool                : meetstation bevat belasting waar een getijperiode een tol speelt (default false)\n- area_geometry: geom       : OPTIONEEL geometrie van het gebied waarbinnen de belasting wordt bepaald (bijv. een gemiddelde waarde)\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_measuringstation.output_ci_postgresql_measuringstation_to_data(\n    output_config\n    df\n)\nSchrijft voor meetstations de belasting data naar de Continu Inzicht database (tabel: data).\nYaml example:\ntype: ci_postgresql_measuringstation_to_data\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nunit_conversion_factor: 0.01\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- measurement_location_id: int64\n- date_time: datetime64[ns, UTC]\n- value: float64\n- value_type: str\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\nunit_conversion_factor (optioneel, float): conversiefactor om waarde om te zetten naar meters\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_measuringstation.output_ci_postgresql_to_moments(\n    output_config\n    df\n)\nSchrijft moments naar Continu Inzicht database (tabel: moments)\nYaml example:\ntype: ci_postgresql_to_moments\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_whatif\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- date_time: int64      : datum/tijd van het huidige moment\n- calc_time: int64      : datum/tijd van eerst volgende rekenstap\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_measuringstation.output_ci_postgresql_to_states(\n    output_config\n    df\n)\nSchrijft voor meetstations de classificatie data naar de Continu Inzicht database (tabel: states).\nYaml example:\ntype: ci_postgresql_to_states\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- measurement_location_id: int64\n- date_time: datetime64[ns, UTC]\n- hours: int64\n- upper_boundary: int64\n- value: float64\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht"
  },
  {
    "objectID": "reference/output_measuringstation.html#functions",
    "href": "reference/output_measuringstation.html#functions",
    "title": "output_measuringstation",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\noutput_ci_postgresql_conditions\nSchrijft voor condities van belastingen voor meetstations naar de Continu Inzicht database (tabel: conditions).\n\n\noutput_ci_postgresql_measuringstation\nSchrijft voor meetstations de classificatie data naar de Continu Inzicht database (tabel: states).\n\n\noutput_ci_postgresql_measuringstation_to_data\nSchrijft voor meetstations de belasting data naar de Continu Inzicht database (tabel: data).\n\n\noutput_ci_postgresql_to_moments\nSchrijft moments naar Continu Inzicht database (tabel: moments)\n\n\noutput_ci_postgresql_to_states\nSchrijft voor meetstations de classificatie data naar de Continu Inzicht database (tabel: states).\n\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_measuringstation.output_ci_postgresql_conditions(\n    output_config\n    df\n)\nSchrijft voor condities van belastingen voor meetstations naar de Continu Inzicht database (tabel: conditions).\nYaml example:\ntype: ci_postgresql_conditions\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_whatif\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- id: int64                 : id van de conditie\n- stateid: int64            : id van de status van een conditie\n- objectid: int64           : id van het object waartoe de conditie behoort (altijd in combinatie met objecttype)\n- objecttype: str           : het type object waartoe de conditie behoort (bijv. een 'section' of 'measuringstation')\n- upperboundary: float64    : de bovengrenswaarde van de status van een conditie (overgang van de betreffende status naar de volgende status)\n- name: str                 : naam van de status van de conditie\n- description: str          : omschrijving van de status van de conditie\n- color: str                : HEX kleurcode van de kleur van de status van de conditie\n- statevalue: float64       : middenwaarde van statusovergangen (specifiek voor objecttype 'sections')\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_measuringstation.output_ci_postgresql_measuringstation(\n    output_config\n    df\n)\nSchrijft voor meetstations de classificatie data naar de Continu Inzicht database (tabel: states).\nYaml example:\ntype: ci_postgresql_measuringstation\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_whatif\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- id: int64                 : id van het meetstation\n- name: str                 : naam van het meetstation\n- code: str                 : code van het meetstation\n- source: str               : bron van de data van het meetstation\n- geometry: geom            : geometrie (ligging) van het meetstation (let op projectie!)\n- tide: bool                : meetstation bevat belasting waar een getijperiode een tol speelt (default false)\n- area_geometry: geom       : OPTIONEEL geometrie van het gebied waarbinnen de belasting wordt bepaald (bijv. een gemiddelde waarde)\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_measuringstation.output_ci_postgresql_measuringstation_to_data(\n    output_config\n    df\n)\nSchrijft voor meetstations de belasting data naar de Continu Inzicht database (tabel: data).\nYaml example:\ntype: ci_postgresql_measuringstation_to_data\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nunit_conversion_factor: 0.01\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- measurement_location_id: int64\n- date_time: datetime64[ns, UTC]\n- value: float64\n- value_type: str\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\nunit_conversion_factor (optioneel, float): conversiefactor om waarde om te zetten naar meters\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_measuringstation.output_ci_postgresql_to_moments(\n    output_config\n    df\n)\nSchrijft moments naar Continu Inzicht database (tabel: moments)\nYaml example:\ntype: ci_postgresql_to_moments\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_whatif\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- date_time: int64      : datum/tijd van het huidige moment\n- calc_time: int64      : datum/tijd van eerst volgende rekenstap\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht\n\n\n\n\nbase.adapters.output.continu_inzicht_postgresql.output_measuringstation.output_ci_postgresql_to_states(\n    output_config\n    df\n)\nSchrijft voor meetstations de classificatie data naar de Continu Inzicht database (tabel: states).\nYaml example:\ntype: ci_postgresql_to_states\ndatabase: \"geoserver\"\nschema: \"continuinzicht_demo_realtime\"\nArgs:\n* output_config (dict): configuratie opties\n* df (DataFrame):\n\n- measurement_location_id: int64\n- date_time: datetime64[ns, UTC]\n- hours: int64\n- upper_boundary: int64\n- value: float64\nOpmerking:\nIn de .env environment bestand moeten de volgende parameters staan:\n\npostgresql_user (str): inlog gebruikersnaam van de Continu Inzicht database\npostgresql_password (str): inlog wachtwoord van de Continu Inzicht database\npostgresql_host (str): servernaam/ ip adres van de Continu Inzicht databaseserver\npostgresql_port (str): poort van de Continu Inzicht databaseserver\n\nIn de ‘yaml’ config moeten de volgende parameters staan:\n\ndatabase (str): database van de Continu Inzicht\nschema (str): schema van de Continu Inzicht"
  },
  {
    "objectID": "reference/proof_of_concept.example_module.html",
    "href": "reference/proof_of_concept.example_module.html",
    "title": "proof_of_concept.example_module",
    "section": "",
    "text": "proof_of_concept.example_module\n\n\n\n\n\nName\nDescription\n\n\n\n\nValuesDivideTwo\nVoorbeeld class die laat zien hoe de arcitectuur werkt\n\n\nValuesTimesTwo\nVoorbeeld class die laat zien hoe de arcitectuur werkt\n\n\n\n\n\nproof_of_concept.example_module.ValuesDivideTwo()\nVoorbeeld class die laat zien hoe de arcitectuur werkt\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndivide_two\nVermenigvuldigd de meetstation waardes met 2 als voorbeeld\n\n\nrun\nRunt de funcies en stuur de df terug\n\n\n\n\n\nproof_of_concept.example_module.ValuesDivideTwo.divide_two(dataframe)\nVermenigvuldigd de meetstation waardes met 2 als voorbeeld\n\n\n\nproof_of_concept.example_module.ValuesDivideTwo.run(input, output)\nRunt de funcies en stuur de df terug\n\n\n\n\n\nproof_of_concept.example_module.ValuesTimesTwo()\nVoorbeeld class die laat zien hoe de arcitectuur werkt\nArgs: data_adapter: DataAdapter Leest\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun\nRunt de funcies en stuur de df terug\n\n\ntimes_two\nDeelt de meetstation waardes door 2 als voorbeeld\n\n\n\n\n\nproof_of_concept.example_module.ValuesTimesTwo.run(input, output)\nRunt de funcies en stuur de df terug\n\n\n\nproof_of_concept.example_module.ValuesTimesTwo.times_two(dataframe)\nDeelt de meetstation waardes door 2 als voorbeeld"
  },
  {
    "objectID": "reference/proof_of_concept.example_module.html#classes",
    "href": "reference/proof_of_concept.example_module.html#classes",
    "title": "proof_of_concept.example_module",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nValuesDivideTwo\nVoorbeeld class die laat zien hoe de arcitectuur werkt\n\n\nValuesTimesTwo\nVoorbeeld class die laat zien hoe de arcitectuur werkt\n\n\n\n\n\nproof_of_concept.example_module.ValuesDivideTwo()\nVoorbeeld class die laat zien hoe de arcitectuur werkt\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndivide_two\nVermenigvuldigd de meetstation waardes met 2 als voorbeeld\n\n\nrun\nRunt de funcies en stuur de df terug\n\n\n\n\n\nproof_of_concept.example_module.ValuesDivideTwo.divide_two(dataframe)\nVermenigvuldigd de meetstation waardes met 2 als voorbeeld\n\n\n\nproof_of_concept.example_module.ValuesDivideTwo.run(input, output)\nRunt de funcies en stuur de df terug\n\n\n\n\n\nproof_of_concept.example_module.ValuesTimesTwo()\nVoorbeeld class die laat zien hoe de arcitectuur werkt\nArgs: data_adapter: DataAdapter Leest\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in\n\n\n\ndf_out\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun\nRunt de funcies en stuur de df terug\n\n\ntimes_two\nDeelt de meetstation waardes door 2 als voorbeeld\n\n\n\n\n\nproof_of_concept.example_module.ValuesTimesTwo.run(input, output)\nRunt de funcies en stuur de df terug\n\n\n\nproof_of_concept.example_module.ValuesTimesTwo.times_two(dataframe)\nDeelt de meetstation waardes door 2 als voorbeeld"
  },
  {
    "objectID": "reference/SectionsFailureprobability.html",
    "href": "reference/SectionsFailureprobability.html",
    "title": "SectionsFailureprobability",
    "section": "",
    "text": "sections.SectionsFailureprobability()\nBepaal de faalkans van een dijkvak\n\n\n**input_schema_failureprobability (DataFrame): schema voor de lijst met dijkvakken\n\nsection_id: int64 : id van de dijkvak\nfailuremechanism_id: int64 : id van het faalmechanisme\nvalue_parameter_id: int64 : id van de belastingparameter (1,2,3,4)\nparameter_id: int64 : id van de faalkans parameter (5,100,101,102)\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : belasting van de tijdreeksitem\n\n\n\n\n**df_out (DataFrame): uitvoer\n\nsection_id: int64 : id van het dijkvak\nfailuremechanism_id: int64 : id van het faalmechanisme\nvalue_parameter_id: int64 : id van de belastingparameter (1,2,3,4)\nparameter_id: int64 : id van de faalkans parameter (5,100,101,102)\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nfailureprobability: float64 : faalkans van de tijdreeksitem\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in_failureprobability\nDataFrame: lijst met faalkansen op een dijkvak voor verschillende faalmechanisms en maatregelen.\n\n\ndf_out\nDataFrame: uitvoer.\n\n\ninput_schema_failureprobability\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun\nUitvoeren van het bepalen van de faalkans van een dijkvak.\n\n\n\n\n\nsections.SectionsFailureprobability.run(input, output)\nUitvoeren van het bepalen van de faalkans van een dijkvak. TODO RW aanpassen\n\n\ninput: (str) Faalkans per dijkvak output: str\nuitvoer sectie van het yaml-bestand: koppeling van de maatgevende meetlocaties per dijkvak\nDataframe: Pandas dataframe geschikt voor uitvoer:\n    - Meetlocatie id (measurement_location_id)\n    - Meetlocatie code (measurement_location_code)\n    - Meetlocatie omschrijving/naam (measurement_location_description)\n    - Parameter id overeenkomstig Aquo-standaard: '4724' (parameter_id)\n    - Parameter code overeenkomstig Aquo-standaard: 'WATHTE' (parameter_code)\n    - Parameter omschrijving overeenkomstig Aquo-standaard: 'Waterhoogte' (parameter_description)\n    - Eenheid (unit)\n    - Datum en tijd (date_time)\n    - Waarde (value)\n    - Type waarde: meting of verwachting (value_type)"
  },
  {
    "objectID": "reference/SectionsFailureprobability.html#input-schemas",
    "href": "reference/SectionsFailureprobability.html#input-schemas",
    "title": "SectionsFailureprobability",
    "section": "",
    "text": "**input_schema_failureprobability (DataFrame): schema voor de lijst met dijkvakken\n\nsection_id: int64 : id van de dijkvak\nfailuremechanism_id: int64 : id van het faalmechanisme\nvalue_parameter_id: int64 : id van de belastingparameter (1,2,3,4)\nparameter_id: int64 : id van de faalkans parameter (5,100,101,102)\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : belasting van de tijdreeksitem"
  },
  {
    "objectID": "reference/SectionsFailureprobability.html#output-schema",
    "href": "reference/SectionsFailureprobability.html#output-schema",
    "title": "SectionsFailureprobability",
    "section": "",
    "text": "**df_out (DataFrame): uitvoer\n\nsection_id: int64 : id van het dijkvak\nfailuremechanism_id: int64 : id van het faalmechanisme\nvalue_parameter_id: int64 : id van de belastingparameter (1,2,3,4)\nparameter_id: int64 : id van de faalkans parameter (5,100,101,102)\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nfailureprobability: float64 : faalkans van de tijdreeksitem"
  },
  {
    "objectID": "reference/SectionsFailureprobability.html#attributes",
    "href": "reference/SectionsFailureprobability.html#attributes",
    "title": "SectionsFailureprobability",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in_failureprobability\nDataFrame: lijst met faalkansen op een dijkvak voor verschillende faalmechanisms en maatregelen.\n\n\ndf_out\nDataFrame: uitvoer.\n\n\ninput_schema_failureprobability\ndict() -&gt; new empty dictionary"
  },
  {
    "objectID": "reference/SectionsFailureprobability.html#methods",
    "href": "reference/SectionsFailureprobability.html#methods",
    "title": "SectionsFailureprobability",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrun\nUitvoeren van het bepalen van de faalkans van een dijkvak.\n\n\n\n\n\nsections.SectionsFailureprobability.run(input, output)\nUitvoeren van het bepalen van de faalkans van een dijkvak. TODO RW aanpassen\n\n\ninput: (str) Faalkans per dijkvak output: str\nuitvoer sectie van het yaml-bestand: koppeling van de maatgevende meetlocaties per dijkvak\nDataframe: Pandas dataframe geschikt voor uitvoer:\n    - Meetlocatie id (measurement_location_id)\n    - Meetlocatie code (measurement_location_code)\n    - Meetlocatie omschrijving/naam (measurement_location_description)\n    - Parameter id overeenkomstig Aquo-standaard: '4724' (parameter_id)\n    - Parameter code overeenkomstig Aquo-standaard: 'WATHTE' (parameter_code)\n    - Parameter omschrijving overeenkomstig Aquo-standaard: 'Waterhoogte' (parameter_description)\n    - Eenheid (unit)\n    - Datum en tijd (date_time)\n    - Waarde (value)\n    - Type waarde: meting of verwachting (value_type)"
  },
  {
    "objectID": "reference/SectionsMeasureFailureprobability.html",
    "href": "reference/SectionsMeasureFailureprobability.html",
    "title": "SectionsMeasureFailureprobability",
    "section": "",
    "text": "sections.SectionsMeasureFailureprobability()\nBepaal de faalkans door een maatregel van een dijkvak\n\n\n**input_schema_fragility_curves (DataFrame):\n\nsection_id: int64 : id van het dijkvak\nmeasure_id: int64 : id van de maatregel\nmeasure: str : naam van de maatregel\nfailuremechanismid: int64 : id van het faalmechanisme\nfailuremechanism: str : code van het faalmechanisme\nhydraulicload: float64 : belasting\nfailureprobability: float64 : faalkans\nsuccessrate: float64 : slagingskans van de maatregel\n\n**input_schema_loads (DataFrame):\n\nsection_id: int64 : id van het dijkvak\nparameter_id: int64 : id van de belastingparameter (1,2,3,4)\nunit: str : eenheid van de belastingparameter\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : belasting van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\n\n\n\n\n**df_out (DataFrame): uitvoer\n\nsection_id: int64 : id van het dijkvak\nparameter_id: int64 : id van de faalkans parameter (5,100,101,102)\nunit: str : eenheid van de belastingparameter\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : belasting van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\nfailureprobability float64 : faalkans bepaald voor de tijdreeksitem\nfailuremechanism: str : code van het faalmechanisme\nmeasure_id: int : id van de maatregel\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in_fragility_curves\nDataFrame: fragility curves voor de dijkvak.\n\n\ndf_in_section_loads\nDataFrame: tijdreeks met belasting op de dijkvak.\n\n\ndf_out\nDataFrame: uitvoer.\n\n\ninput_schema_fragility_curves\ndict() -&gt; new empty dictionary\n\n\ninput_schema_loads\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrun\nUitvoeren van het bepalen van de faalkans van een dijkvak met maatregel.\n\n\n\n\n\nsections.SectionsMeasureFailureprobability.run(input, output)\nUitvoeren van het bepalen van de faalkans van een dijkvak met maatregel.\nArgs:\ninput (list[str]): Lijst met namen van configuratie:\n    [0] tijdreeks met belasting op de dijkvak\n    [1] fragility curves voor de dijkvak\noutput (str): uitvoer sectie van het yaml-bestand."
  },
  {
    "objectID": "reference/SectionsMeasureFailureprobability.html#input-schemas",
    "href": "reference/SectionsMeasureFailureprobability.html#input-schemas",
    "title": "SectionsMeasureFailureprobability",
    "section": "",
    "text": "**input_schema_fragility_curves (DataFrame):\n\nsection_id: int64 : id van het dijkvak\nmeasure_id: int64 : id van de maatregel\nmeasure: str : naam van de maatregel\nfailuremechanismid: int64 : id van het faalmechanisme\nfailuremechanism: str : code van het faalmechanisme\nhydraulicload: float64 : belasting\nfailureprobability: float64 : faalkans\nsuccessrate: float64 : slagingskans van de maatregel\n\n**input_schema_loads (DataFrame):\n\nsection_id: int64 : id van het dijkvak\nparameter_id: int64 : id van de belastingparameter (1,2,3,4)\nunit: str : eenheid van de belastingparameter\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : belasting van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)"
  },
  {
    "objectID": "reference/SectionsMeasureFailureprobability.html#output-schema",
    "href": "reference/SectionsMeasureFailureprobability.html#output-schema",
    "title": "SectionsMeasureFailureprobability",
    "section": "",
    "text": "**df_out (DataFrame): uitvoer\n\nsection_id: int64 : id van het dijkvak\nparameter_id: int64 : id van de faalkans parameter (5,100,101,102)\nunit: str : eenheid van de belastingparameter\ndate_time: datetime64[ns, UTC] : datum/ tijd van de tijdreeksitem\nvalue: float64 : belasting van de tijdreeksitem\nvalue_type: str : type waarde van de tijdreeksitem (meting of verwacht)\nfailureprobability float64 : faalkans bepaald voor de tijdreeksitem\nfailuremechanism: str : code van het faalmechanisme\nmeasure_id: int : id van de maatregel"
  },
  {
    "objectID": "reference/SectionsMeasureFailureprobability.html#attributes",
    "href": "reference/SectionsMeasureFailureprobability.html#attributes",
    "title": "SectionsMeasureFailureprobability",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_in_fragility_curves\nDataFrame: fragility curves voor de dijkvak.\n\n\ndf_in_section_loads\nDataFrame: tijdreeks met belasting op de dijkvak.\n\n\ndf_out\nDataFrame: uitvoer.\n\n\ninput_schema_fragility_curves\ndict() -&gt; new empty dictionary\n\n\ninput_schema_loads\ndict() -&gt; new empty dictionary"
  },
  {
    "objectID": "reference/SectionsMeasureFailureprobability.html#methods",
    "href": "reference/SectionsMeasureFailureprobability.html#methods",
    "title": "SectionsMeasureFailureprobability",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrun\nUitvoeren van het bepalen van de faalkans van een dijkvak met maatregel.\n\n\n\n\n\nsections.SectionsMeasureFailureprobability.run(input, output)\nUitvoeren van het bepalen van de faalkans van een dijkvak met maatregel.\nArgs:\ninput (list[str]): Lijst met namen van configuratie:\n    [0] tijdreeks met belasting op de dijkvak\n    [1] fragility curves voor de dijkvak\noutput (str): uitvoer sectie van het yaml-bestand."
  },
  {
    "objectID": "reference/ShiftFragilityCurveOvertopping.html",
    "href": "reference/ShiftFragilityCurveOvertopping.html",
    "title": "ShiftFragilityCurveOvertopping",
    "section": "",
    "text": "fragility_curves.ShiftFragilityCurveOvertopping()\nVerschuift de fragility curve met een gegeven effect\n\n\n\n\n\nName\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_bed_levels\n\n\n\ndf_out\n\n\n\ndf_slopes\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor golf overslag & shift de curve met een gegeven effect\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.ShiftFragilityCurveOvertopping.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.ShiftFragilityCurveOvertopping.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand. Parameters: input (list[str]): Een lijst met de bestandsnamen van de inputbestanden. output (str): De bestandsnaam waarin het resultaat moet worden opgeslagen. Returns: None\n\n\n\nfragility_curves.ShiftFragilityCurveOvertopping.load(input)\nLaad een fragility curve in\n\n\n\nfragility_curves.ShiftFragilityCurveOvertopping.refine(waterlevels)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.ShiftFragilityCurveOvertopping.run(input, output, effect)\nRunt de berekening van de fragility curve voor golf overslag & shift de curve met een gegeven effect\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_slopes (pd.DataFrame), [1] df_profile (pd.DataFrame), [2] df_bed_levels (pd.DataFrame)\nrequired\n\n\noutput\nstr\nFragility curve output\nrequired\n\n\neffect\nfloat\nVerschuiving van de fragility curve\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_slopes (pd.DataFrame)\n\n        DataFrame met helling data.\n        Moet de volgende kolommen bevatten:\n        - x : float\n        - y : float\n        - r : float\n        - slopetypeid : int (1: dike or 2: slope)\n\n   [1] df_profile (pd.DataFrame):\n        DataFrame met profiel data.\n        Moet de volgende kolommen bevatten:\n        - windspeed : float\n        - sectormin : float\n        - sectorsize : float\n        - orientation : float (in graden)\n        - crestlevel : float (in meters)\n        - dam : int (0: geen dam or 1: dam)\n        - damheight : float (in meters)\n        - qcr : float (waarde in m^3/s)\n            str (close | open)\n            tuple (waarden van mu en sigma)\n\n   [2] df_bed_levels (pd.DataFrame):\n        DataFrame met bed level data.\n        Moet de volgende kolommen bevatten:\n        - direction : float\n        - bedlevel : float\n        - fetch : float\n\n\n\n\nfragility_curves.ShiftFragilityCurveOvertopping.shift(effect)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  },
  {
    "objectID": "reference/ShiftFragilityCurveOvertopping.html#attributes",
    "href": "reference/ShiftFragilityCurveOvertopping.html#attributes",
    "title": "ShiftFragilityCurveOvertopping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndata_adapter\n\n\n\ndf_bed_levels\n\n\n\ndf_out\n\n\n\ndf_slopes\n\n\n\nfragility_curve_schema\ndict() -&gt; new empty dictionary"
  },
  {
    "objectID": "reference/ShiftFragilityCurveOvertopping.html#methods",
    "href": "reference/ShiftFragilityCurveOvertopping.html#methods",
    "title": "ShiftFragilityCurveOvertopping",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nas_array\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\ncalculate_fragility_curve\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand.\n\n\nload\nLaad een fragility curve in\n\n\nrefine\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\nrun\nRunt de berekening van de fragility curve voor golf overslag & shift de curve met een gegeven effect\n\n\nshift\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen\n\n\n\n\n\nfragility_curves.ShiftFragilityCurveOvertopping.as_array()\nGeeft curve terug als numpy array, deze kunnen vervolgens worden gestacked en in een database geplaatst\n\n\n\nfragility_curves.ShiftFragilityCurveOvertopping.calculate_fragility_curve(\n    input\n    output\n)\nBereken de fragiliteitscurve op basis van de opgegeven input en sla het resultaat op in het opgegeven outputbestand. Parameters: input (list[str]): Een lijst met de bestandsnamen van de inputbestanden. output (str): De bestandsnaam waarin het resultaat moet worden opgeslagen. Returns: None\n\n\n\nfragility_curves.ShiftFragilityCurveOvertopping.load(input)\nLaad een fragility curve in\n\n\n\nfragility_curves.ShiftFragilityCurveOvertopping.refine(waterlevels)\nInterpolleer de fragility curve op de gegeven waterstanden\n\n\n\nfragility_curves.ShiftFragilityCurveOvertopping.run(input, output, effect)\nRunt de berekening van de fragility curve voor golf overslag & shift de curve met een gegeven effect\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nlist[str]\n[0] df_slopes (pd.DataFrame), [1] df_profile (pd.DataFrame), [2] df_bed_levels (pd.DataFrame)\nrequired\n\n\noutput\nstr\nFragility curve output\nrequired\n\n\neffect\nfloat\nVerschuiving van de fragility curve\nrequired\n\n\n\n\n\n\ninput: list[str]\n   [0] df_slopes (pd.DataFrame)\n\n        DataFrame met helling data.\n        Moet de volgende kolommen bevatten:\n        - x : float\n        - y : float\n        - r : float\n        - slopetypeid : int (1: dike or 2: slope)\n\n   [1] df_profile (pd.DataFrame):\n        DataFrame met profiel data.\n        Moet de volgende kolommen bevatten:\n        - windspeed : float\n        - sectormin : float\n        - sectorsize : float\n        - orientation : float (in graden)\n        - crestlevel : float (in meters)\n        - dam : int (0: geen dam or 1: dam)\n        - damheight : float (in meters)\n        - qcr : float (waarde in m^3/s)\n            str (close | open)\n            tuple (waarden van mu en sigma)\n\n   [2] df_bed_levels (pd.DataFrame):\n        DataFrame met bed level data.\n        Moet de volgende kolommen bevatten:\n        - direction : float\n        - bedlevel : float\n        - fetch : float\n\n\n\n\nfragility_curves.ShiftFragilityCurveOvertopping.shift(effect)\nSchuift de waterstanden van de fragility curve op (voor een noodmaatregel), en interpoleer de faalkansen op het oorspronkelijke waterstandsgrid"
  }
]